// ===== CCA Telemetry: ESP32-S3 + TWAI + RaceChrono DIY BLE (CAN + GPS) =====
// - Robust BLE reconnect (no NimBLE deinit on S3; stop/start advertiser only)
// - TWAI CAN RX burst buffering + per-PID throttle
// - Profile allow-list (car mode) vs sniff-all (bench mode)
// - Oil pressure analog on GPIO1 -> CAN 0x710 (0.1 psi/bit, big-endian)
// - Flash config (Preferences): V0_ADC, V1_ADC, PROFILE, custom dividers
// - RaceChrono DIY BLE service 0x1FF8 with:
//      0x0001 CAN main (READ+NOTIFY)
//      0x0002 CAN filter (WRITE)
//      0x0003 GPS main (READ+NOTIFY)
//      0x0004 GPS time (READ+NOTIFY)
// - Serial CLI (CR, LF, CRLF, or none)
//
// Libs:
//   ESP32-TWAI-CAN
//   NimBLE-Arduino
//   Preferences
//
// Board: ESP32S3 Dev Module

#include <ESP32-TWAI-CAN.hpp>
#include <NimBLEDevice.h>
#include <NimBLEUtils.h>
#if defined(CONFIG_NIMBLE_CPP_IDF)
#include "host/ble_gap.h"
#include "host/ble_hs.h"
#include "host/ble_att.h"
#else
#include "nimble/nimble/host/include/host/ble_gap.h"
#include "nimble/nimble/host/include/host/ble_hs.h"
#include "nimble/nimble/host/include/host/ble_att.h"
#endif
#include "nimble/porting/nimble/include/os/os_mempool.h"
#include <Preferences.h>
#include <esp_gatt_defs.h>
#include <esp_random.h>
#include <cstdio>
#include <cstring>
#include <cstdint>
#include <ctype.h>
#include <driver/twai.h>
#include <math.h>
#include <esp_system.h>
#include <esp_task_wdt.h>
#include <esp_heap_caps.h>
#if defined(__has_include)
#if __has_include(<esp_idf_version.h>)
#include <esp_idf_version.h>
#endif
#endif
#include "config.h"   // must define DEFAULT_UPDATE_RATE_DIVIDER and DEVICE_NAME
#include "src/gps_nmea.h"
#include "src/sched.hpp"
#include "src/nvs_cfg.h"
#include "src/led_status.h"

#ifndef PASSKEY_U32
#define PASSKEY_U32 123456
#endif

#ifndef DEV_TRUST_FIL
#define DEV_TRUST_FIL 0
#endif

// ---------- Version ----------
#ifndef FW_VERSION
#define FW_VERSION "0.6.1"
#endif
#ifndef FW_GITHASH
#define FW_GITHASH "esp32s3"
#endif
static const char FW_VERSION_STRING[] = FW_VERSION " (" FW_GITHASH ")";

// ===== Pins (S3 <-> SN65HVD230) =====
#define CAN_TX 5
#define CAN_RX 4

// ===== GPS pins (UART1) =====
#define GPS_RX_GPIO 18   // GPS TX -> ESP RX
#define GPS_TX_GPIO 17   // GPS RX <- ESP TX (PMTK)

// ===== GPS PMTK sequences =====
static const char *PMTK_SET_NMEA_OUTPUT_RMCGGA = "$PMTK314,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0*28\r\n";
static const char *PMTK_SET_NMEA_UPDATE_10HZ   = "$PMTK220,100*2F\r\n";
static const char *PMTK_SET_BAUD_115200        = "$PMTK251,115200*1F\r\n";

// ===== BLE UUIDs (RaceChrono DIY) =====
static const char* RC_SERVICE_UUID   = "00001ff8-0000-1000-8000-00805f9b34fb";
static const char* RC_CHAR_CAN_UUID  = "00000001-0000-1000-8000-00805f9b34fb"; // READ+NOTIFY
static const char* RC_CHAR_FIL_UUID  = "00000002-0000-1000-8000-00805f9b34fb"; // WRITE
static const char* RC_CHAR_GPS_UUID  = "00000003-0000-1000-8000-00805f9b34fb"; // READ+NOTIFY
static const char* RC_CHAR_GTM_UUID  = "00000004-0000-1000-8000-00805f9b34fb"; // READ+NOTIFY
static const char* RC_CHAR_DIAG_UUID = "00000005-0000-1000-8000-00805f9b34fb"; // READ+NOTIFY

// ====== (Fix) Governor snapshot: define early so Arduino doesn't mangle prototypes ======
struct GovernorSnapshot { uint32_t pid; uint8_t governor; };
struct NimblePoolWatermark { uint16_t minFreeBlocks; uint16_t blockSize; };
static constexpr size_t   BLE_GOVERNOR_SNAPSHOT_MAX = 128;
static size_t capture_governor_snapshot(GovernorSnapshot *out);
static bool   restore_governor_snapshot(const GovernorSnapshot *snapshots, size_t count);

// ====== Forward declarations to satisfy Arduino's autogenerated prototypes ======
struct PidExtra;
static void resetSkippedUpdatesCounters();
static int64_t gpsComputeMonotonicUs(uint32_t micros_now, int64_t correction_us);
static void gpsHandlePpsDiscipline(uint32_t now_ms);
static void IRAM_ATTR gpsPpsIsr();
static void gpsMarkSentenceStale();
static void bleNotifyBackoffReset();
static void bleNotifyBackoffService(uint32_t now);
static void bleApplyNegotiatedMtu(uint16_t mtu);
static void bleResetNotifySizing();
static void bleHandleNotifyStatus(const char *label, int code);

// ===== Global state =====
static bool     isCanBusReaderActive = false;
static uint32_t lastCanMessageReceivedMs = 0;
static uint32_t loop_iteration = 0;
static uint16_t num_can_bus_timeouts = 0;

static bool     have_seen_any_can = false;
static uint32_t lastHbMs = 0;
static uint16_t hbCounter = 0;
static const uint32_t HB_PID = 0x7AA; // BLE heartbeat

static constexpr uint32_t MS_PER_SECOND = 1000;
static constexpr uint32_t MS_PER_MINUTE = 60 * MS_PER_SECOND;
static constexpr uint32_t MS_PER_HOUR   = 60 * MS_PER_MINUTE;
static constexpr uint32_t MS_PER_DAY    = 24 * MS_PER_HOUR;

static uint32_t rxCount = 0;
static uint32_t lastRxPrintMs = 0;
static constexpr uint32_t CAN_RX_PRINT_INTERVAL_MS = 200;

static constexpr uint16_t kBaseCanNotifiesPerLoop = 20;
static constexpr uint16_t BLE_BASE_NOTIFY_PAYLOAD = 20;
static constexpr uint32_t BLE_NOTIFY_BASE_BUDGET_BYTES =
    static_cast<uint32_t>(kBaseCanNotifiesPerLoop) * BLE_BASE_NOTIFY_PAYLOAD;
static constexpr uint32_t NOTIFY_CAP_LOG_INTERVAL_MS = 2000;
static uint16_t canNotifiesThisLoop = 0;
static bool notifyCapHitCurrentLoop = false;
static uint32_t notifyCapHitsSinceLastLog = 0;
static uint32_t notifyCapLastLogMs = 0;
static uint32_t notifies_suppressed_total = 0;
static uint16_t g_bleNotifyBurstBudgetPerLoop = kBaseCanNotifiesPerLoop;

static uint16_t g_bleNegotiatedMtu = BLE_ATT_MTU_DFLT;
static uint16_t g_bleNotifyMaxValueLength = (BLE_ATT_MTU_DFLT > 3) ? (BLE_ATT_MTU_DFLT - 3) : 0;
static uint32_t bleNotifyFailuresTotal = 0;
static uint32_t bleNotifyStatusErrors = 0;
static uint32_t bleNotifyCongestionEvents = 0;
static uint32_t bleNotifyClampEvents = 0;
static uint32_t bleNotifyFailureLastLogMs = 0;
static uint32_t bleNotifyClampLastLogMs = 0;
static uint32_t bleNotifyBackoffEvents = 0;
static uint32_t bleNotifyBackoffLastLogMs = 0;
static uint32_t bleNotifyBackoffUntilMs = 0;
static uint8_t  bleNotifyBackoffLevel = 0;
static bool     bleNotifyBackoffActive = false;
static int      bleNotifyLastStatusCode = 0;
static uint32_t bleNotifyLastStatusMs = 0;
static char     bleNotifyBackoffLastReason[48] = "none";
static constexpr uint32_t BLE_NOTIFY_FAILURE_LOG_INTERVAL_MS = 2000;
static constexpr uint32_t BLE_NOTIFY_CLAMP_LOG_INTERVAL_MS   = 5000;
static constexpr uint32_t BLE_NOTIFY_BACKOFF_LOG_INTERVAL_MS = 5000;
static constexpr uint8_t  BLE_NOTIFY_BACKOFF_MAX_LEVEL       = 5;
static constexpr uint32_t BLE_NOTIFY_BACKOFF_BASE_MS         = 20;
static constexpr uint32_t BLE_NOTIFY_BACKOFF_MAX_MS          = 640;
static GovernorSnapshot bleNotifyBackoffSnapshot[BLE_GOVERNOR_SNAPSHOT_MAX];
static size_t bleNotifyBackoffSnapshotCount = 0;

static volatile uint32_t gps_pps_event_micros = 0;
static volatile uint32_t gps_pps_last_interval_us = 0;
static volatile uint32_t gps_pps_event_count = 0;
static volatile uint32_t gps_pps_last_isr_micros = 0;
[[maybe_unused]] static double   gps_pps_drift_estimate_us = 0.0;
static int64_t  gps_time_correction_us = 0;
[[maybe_unused]] static bool     gps_pps_locked = false;
[[maybe_unused]] static uint32_t gps_pps_last_processed_ms = 0;

#if GPS_PPS_GPIO >= 0
static constexpr uint32_t GPS_PPS_DEBOUNCE_US = 200000;  // reject pulses <200 ms apart
static constexpr int64_t  GPS_PPS_MAX_SLEW_US = 2000;     // +/-2 ms per second
#endif

static constexpr uint32_t FIL_WRITE_WINDOW_MS = 10000;
static constexpr uint8_t  FIL_WRITE_WINDOW_MAX = 3;
static uint32_t filWriteWindowStartMs = 0;
static uint8_t  filWritesInWindow = 0;

static char lastReconnectCause[64] = "boot";
static char pendingBleRestartReason[64] = "";
static bool pendingBleRestart = false;

static constexpr int TASK_WDT_TIMEOUT_SECONDS = 5;

static constexpr uint32_t CAN_STATUS_POLL_INTERVAL_MS = 1000;
static constexpr uint32_t CAN_TX_FAILURE_WINDOW_MS    = 1000;
static constexpr uint8_t  CAN_TX_FAILURE_THRESHOLD    = 5;

static uint32_t lastCanStatusCheckMs    = 0;
static uint32_t canTxFailureWindowStart = 0;
static uint8_t  canTxFailuresInWindow   = 0;
static uint32_t lastCanDiagSendMs       = 0;
static uint32_t canBusOffCount          = 0;
static uint32_t canRestartCount         = 0;
static uint32_t lastCanRestartMs        = 0;
static twai_status_info_t lastTwaiStatus = {};
static constexpr uint32_t CAN_DIAG_NOTIFY_INTERVAL_MS = 2000;
static constexpr uint32_t CAN_RECOVERY_BACKOFF_MS     = 300;

// ===== GPS state =====
static HardwareSerial GPSSerial(1);
static bool gpsConfigured = false;
static bool gpsUsingRawStream = false;
static bool gpsWarnedNoNmea = false;
static uint32_t gpsLastSentenceMs = 0;
static uint32_t lastGpsNotifyMs = 0;
static uint32_t lastGpsInitAttemptMs = 0;
static constexpr uint32_t GPS_NOTIFY_PERIOD_MS            = 100;  // 10 Hz
static constexpr uint32_t GPS_INIT_RETRY_MS               = 5000;
static constexpr uint32_t GPS_WAIT_BEFORE_115200_MS       = 120;
static constexpr uint32_t GPS_CONFIRM_115200_TIMEOUT_MS   = 2500;
static constexpr uint8_t  GPS_INIT_MAX_115200_ATTEMPTS    = 3;
static const uint32_t     GPS_INIT_PROBE_BAUDS[]          = { 9600, 38400, 57600, 115200 };
static constexpr size_t GPS_INIT_PROBE_BAUD_COUNT = sizeof(GPS_INIT_PROBE_BAUDS) / sizeof(GPS_INIT_PROBE_BAUDS[0]);

enum class GpsInitPhase : uint8_t {
  Idle,
  WaitInitialNmea,
  SendConfigCommand,
  CommandDelay,
  Prepare115200,
  WaitBefore115200,
  Confirm115200,
  BeginFallback,
  FinalizeFallback,
};

static GpsInitPhase gpsInitPhase = GpsInitPhase::Idle;
static uint32_t gpsInitPhaseStartMs = 0;
static uint8_t gpsInitCommandIndex = 0;
static bool gpsInitSawInitialNmea = false;
static bool gpsInitPrevWasDollar = false;
static uint32_t gpsInitFallbackBaud = 9600;
static size_t gpsInitProbeIndex = 0;
static uint32_t gpsInitCurrentBaud = 9600;
static uint8_t gpsInit115200Attempt = 0;

// ====== BLE objects we own (we create the full 0x1FF8 service) ======
static NimBLEServer*         g_server = nullptr;
static NimBLEAdvertising*    g_adv    = nullptr;
static NimBLEService*        g_svc    = nullptr;
static NimBLECharacteristic* g_can    = nullptr; // 0x0001
static NimBLECharacteristic* g_fil    = nullptr; // 0x0002
static NimBLECharacteristic* g_gps    = nullptr; // 0x0003
static NimBLECharacteristic* g_gtm    = nullptr; // 0x0004
static NimBLECharacteristic* g_diag   = nullptr; // 0x0005

static constexpr uint16_t BLE_LINK_PRI_INVALID_HANDLE      = 0xFFFF;
static constexpr uint16_t BLE_LINK_PRI_MIN_INTERVAL_UNITS  = 6;   // 7.5 ms
static constexpr uint16_t BLE_LINK_PRI_MAX_INTERVAL_UNITS  = 12;  // 15 ms
static constexpr uint16_t BLE_LINK_PRI_LATENCY              = 0;
static constexpr uint16_t BLE_LINK_PRI_TIMEOUT_UNITS        = 200; // 2.0 s
static constexpr uint32_t BLE_LINK_PRI_RETRY_DELAY_MS       = 2000;

static bool     g_bleLinkPriEnabled           = true;
static bool     g_bleLinkPriCallbacksAttached = false;
static uint16_t g_bleLinkPriConnHandle        = BLE_LINK_PRI_INVALID_HANDLE;
static bool     g_bleLinkPriRetryArmed        = false;
static bool     g_bleLinkPriRetryDone         = false;
static uint32_t g_bleLinkPriRetryAtMs         = 0;

static bool bleLinkPri_requestConnParams(uint16_t connHandle, const char *label);
static void bleLinkPri_resetState();
static void bleLinkPri_onConnect(NimBLEConnInfo& connInfo);
static void bleLinkPri_onDisconnect();
static void bleLinkPri_service(uint32_t now);
static void bleLinkPri_attachIfReady();
static void refreshBleLed();
static void resetStatusIndicatorsForDisconnect();

void bleLinkPri_setEnabled(bool enabled);
bool bleLinkPri_isEnabled();

class BleLinkPriCallbacks : public NimBLEServerCallbacks {
 public:
  void onConnect(NimBLEServer*, NimBLEConnInfo& connInfo) override {
    bleNotifyBackoffReset();
    bleApplyNegotiatedMtu(connInfo.getMTU());
    bleLinkPri_onConnect(connInfo);
  }

  void onDisconnect(NimBLEServer*, NimBLEConnInfo&, int) override {
    bleNotifyBackoffReset();
    bleResetNotifySizing();
    bleLinkPri_onDisconnect();
  }

  void onMTUChange(uint16_t MTU, NimBLEConnInfo&) override {
    Serial.printf("MTU negotiated: %u\n", static_cast<unsigned>(MTU));
    bleApplyNegotiatedMtu(MTU);
  }

  void onConnParamsUpdate(NimBLEConnInfo& connInfo) override {
    float intervalMs = static_cast<float>(connInfo.getConnInterval()) * 1.25f;
    float timeoutSec = static_cast<float>(connInfo.getConnTimeout()) * 0.010f;
    Serial.printf("ConnParams update: interval=%.2f ms latency=%u timeout=%.2f s\n",
                  intervalMs,
                  static_cast<unsigned>(connInfo.getConnLatency()),
                  timeoutSec);
  }
} static g_bleLinkPriCallbacks;

static void bleLinkPri_resetState() {
  g_bleLinkPriConnHandle = BLE_LINK_PRI_INVALID_HANDLE;
  g_bleLinkPriRetryArmed = false;
  g_bleLinkPriRetryDone = false;
  g_bleLinkPriRetryAtMs = 0;
}

static void bleLinkPri_attachIfReady() {
  if (g_bleLinkPriCallbacksAttached) return;
  if (!g_server) return;
  g_server->setCallbacks(&g_bleLinkPriCallbacks, false);
  g_bleLinkPriCallbacksAttached = true;
}

static bool bleLinkPri_requestConnParams(uint16_t connHandle, const char *label) {
  if (!g_server) return false;
  if (connHandle == BLE_LINK_PRI_INVALID_HANDLE) return false;

  const char *tag = (label && label[0]) ? label : "req";
  float minMs = static_cast<float>(BLE_LINK_PRI_MIN_INTERVAL_UNITS) * 1.25f;
  float maxMs = static_cast<float>(BLE_LINK_PRI_MAX_INTERVAL_UNITS) * 1.25f;
  float timeoutSec = static_cast<float>(BLE_LINK_PRI_TIMEOUT_UNITS) * 0.010f;

  ble_gap_upd_params params = {
    .itvl_min = BLE_LINK_PRI_MIN_INTERVAL_UNITS,
    .itvl_max = BLE_LINK_PRI_MAX_INTERVAL_UNITS,
    .latency = BLE_LINK_PRI_LATENCY,
    .supervision_timeout = BLE_LINK_PRI_TIMEOUT_UNITS,
    .min_ce_len = BLE_GAP_INITIAL_CONN_MIN_CE_LEN,
    .max_ce_len = BLE_GAP_INITIAL_CONN_MAX_CE_LEN,
  };

  int rc = ble_gap_update_params(connHandle, &params);
  Serial.printf("ConnParams %s: min=%.2f ms max=%.2f ms lat=%u timeout=%.2f s -> %s",
                tag,
                minMs,
                maxMs,
                static_cast<unsigned>(BLE_LINK_PRI_LATENCY),
                timeoutSec,
                (rc == 0) ? "sent" : "rejected");
  if (rc != 0) {
    Serial.printf(" (err=%d)\n", rc);
  } else {
    Serial.println();
  }
  return rc == 0;
}

static void bleLinkPri_onConnect(NimBLEConnInfo& connInfo) {
  g_bleLinkPriConnHandle = connInfo.getConnHandle();
  g_bleLinkPriRetryDone = false;

  refreshBleLed();
  led_service(millis());

  if (!g_bleLinkPriEnabled) {
    g_bleLinkPriRetryArmed = false;
    return;
  }

  bleLinkPri_requestConnParams(g_bleLinkPriConnHandle, "req");
  g_bleLinkPriRetryArmed = true;
  g_bleLinkPriRetryAtMs = millis() + BLE_LINK_PRI_RETRY_DELAY_MS;
}

static void bleLinkPri_onDisconnect() {
  bleLinkPri_resetState();
  resetStatusIndicatorsForDisconnect();
  refreshBleLed();
  led_service(millis());
}

static void bleLinkPri_service(uint32_t now) {
  if (!g_bleLinkPriEnabled) return;
  if (!g_bleLinkPriRetryArmed) return;
  if (g_bleLinkPriRetryDone) return;
  if (g_bleLinkPriConnHandle == BLE_LINK_PRI_INVALID_HANDLE) return;
  if (static_cast<int32_t>(now - g_bleLinkPriRetryAtMs) < 0) return;

  g_bleLinkPriRetryDone = true;
  g_bleLinkPriRetryArmed = false;
  bleLinkPri_requestConnParams(g_bleLinkPriConnHandle, "retry");
}

void bleLinkPri_setEnabled(bool enabled) {
  if (enabled == g_bleLinkPriEnabled) return;
  g_bleLinkPriEnabled = enabled;

  if (!enabled) {
    g_bleLinkPriRetryArmed = false;
    g_bleLinkPriRetryDone = false;
    return;
  }

  if (g_bleLinkPriConnHandle == BLE_LINK_PRI_INVALID_HANDLE) return;

  bleLinkPri_requestConnParams(g_bleLinkPriConnHandle, "req");
  g_bleLinkPriRetryDone = false;
  g_bleLinkPriRetryArmed = true;
  g_bleLinkPriRetryAtMs = millis() + BLE_LINK_PRI_RETRY_DELAY_MS;
}

bool bleLinkPri_isEnabled() {
  return g_bleLinkPriEnabled;
}

// RMC fields
static int    rmc_hour = 0, rmc_min = 0, rmc_sec = 0, rmc_millis = 0;
static bool   rmc_valid = false;
static double rmc_lat_deg = 0.0, rmc_lon_deg = 0.0;
static double rmc_speed_kmh = 0.0;
static double rmc_course_deg = 0.0;

static bool     rmc_time_available = false;
static uint32_t rmc_ms_since_midnight = 0;
static uint32_t rmc_capture_tick_ms  = 0;
static uint32_t gps_monotonic_ms     = 0;
static uint32_t rmc_capture_tick_us  = 0;

static constexpr int64_t GPS_US_PER_DAY = static_cast<int64_t>(MS_PER_DAY) * 1000LL;

static void IRAM_ATTR gpsPpsIsr() {
#if GPS_PPS_GPIO >= 0
  uint32_t now = micros();
  uint32_t last = gps_pps_last_isr_micros;
  if (last != 0) {
    uint32_t diff = now - last;
    if (diff < GPS_PPS_DEBOUNCE_US) {
      return;
    }
    gps_pps_last_interval_us = diff;
  } else {
    gps_pps_last_interval_us = 1000000;
  }
  gps_pps_last_isr_micros = now;
  gps_pps_event_micros = now;
  if (gps_pps_event_count != 0xFFFFFFFFu) {
    gps_pps_event_count++;
  }
#else
  (void)gps_pps_event_micros;
#endif
}

// GGA fields
static int    gga_sats = 0;
static double gga_hdop = 99.9;
static double gga_alt_m = 0.0;

// Date (UTC)
static int gps_year = 0, gps_mon = 0, gps_day = 0;

// Synchronization bits for RaceChrono DIY GPS payload
static uint8_t gpsSyncBits = 0;
static int lastDateHourPacked = -1;

static char gpsLineBuf[128];
static size_t gpsLineLen = 0;

// ===== RaceChrono pidMap extra (per-PID throttle) =====
struct PidExtra {
  uint8_t baseDivider      = DEFAULT_UPDATE_RATE_DIVIDER;
  uint8_t governorDivider  = 1;
  uint8_t skippedUpdates   = 0;
  uint8_t lastLength       = 0;
  uint8_t lastData[8]      = {0};
  bool    hasLastPayload   = false;
};

// Minimal pid map implementation for allow-listing + extras.
template <typename ExtraT>
class SimplePidMap {
public:
  struct Entry { uint32_t pid; uint16_t intervalMs; ExtraT extra; bool used; };
  static constexpr size_t MAX = 256;
  Entry entries[MAX];

  SimplePidMap(){ reset(); }

  void reset(){ for (auto &e: entries){ e.used=false; e.pid=0; e.intervalMs=0; e.extra=ExtraT(); } }

  bool isEmpty() const { for (auto &e: entries){ if (e.used) return false; } return true; }

  bool allowOnePid(uint32_t pid, uint16_t ms){
    if (getEntryId(pid)) return true;
    for (auto &e: entries){
      if (!e.used){ e.used=true; e.pid=pid; e.intervalMs=ms; e.extra=ExtraT(); return true; }
    }
    return false;
  }

  void* getEntryId(uint32_t pid){
    for (auto &e: entries){ if (e.used && e.pid==pid) return &e; }
    return nullptr;
  }

  uint32_t getPid(void* entry){ return ((Entry*)entry)->pid; }
  ExtraT*  getExtra(void* entry){ return &((Entry*)entry)->extra; }

  ExtraT* getOrCreateExtra(uint32_t pid, uint16_t intervalMs = 0){
    void *entry = getEntryId(pid);
    if (entry) return getExtra(entry);
    for (auto &e: entries){
      if (!e.used){
        e.used = true;
        e.pid = pid;
        e.intervalMs = intervalMs;
        e.extra = ExtraT();
        return &e.extra;
      }
    }
    return nullptr;
  }

  template<typename F>
  void forEach(F f){ for (auto &e: entries){ if (e.used) f((void*)&e); } }
};

static SimplePidMap<PidExtra> pidMap;

static const char *reset_reason_to_string(esp_reset_reason_t reason) {
  switch (reason) {
    case ESP_RST_POWERON:     return "POWERON";
    case ESP_RST_EXT:         return "EXT";
    case ESP_RST_SW:          return "SW";
    case ESP_RST_PANIC:       return "PANIC";
    case ESP_RST_INT_WDT:     return "INT_WDT";
    case ESP_RST_TASK_WDT:    return "TASK_WDT";
    case ESP_RST_WDT:         return "WDT";
    case ESP_RST_DEEPSLEEP:   return "DEEPSLEEP";
    case ESP_RST_BROWNOUT:    return "BROWNOUT";
    case ESP_RST_SDIO:        return "SDIO";
#ifdef ESP_RST_RTC_WDT
    case ESP_RST_RTC_WDT:     return "RTC_WDT";
#endif
#ifdef ESP_RST_USB
    case ESP_RST_USB:         return "USB";
#endif
#ifdef ESP_RST_CPU_LOCKUP
    case ESP_RST_CPU_LOCKUP:  return "CPU_LOCKUP";
#endif
#ifdef ESP_RST_JTAG
    case ESP_RST_JTAG:        return "JTAG";
#endif
#ifdef ESP_RST_TIME_WDT
    case ESP_RST_TIME_WDT:    return "TIME_WDT";
#endif
#ifdef ESP_RST_MWDT0
    case ESP_RST_MWDT0:       return "MWDT0";
#endif
#ifdef ESP_RST_MWDT1
    case ESP_RST_MWDT1:       return "MWDT1";
#endif
#ifdef ESP_RST_RTC_MWDT0
    case ESP_RST_RTC_MWDT0:   return "RTC_MWDT0";
#endif
#ifdef ESP_RST_RTC_MWDT1
    case ESP_RST_RTC_MWDT1:   return "RTC_MWDT1";
#endif
    default:                  return "UNKNOWN";
  }
}

static esp_err_t init_task_wdt_backend() {
#if defined(ESP_TASK_WDT_INIT_CONFIG_DEFAULT)
  esp_task_wdt_config_t cfg = ESP_TASK_WDT_INIT_CONFIG_DEFAULT();
  cfg.timeout_ms = TASK_WDT_TIMEOUT_SECONDS * 1000;
  cfg.trigger_panic = true;
  return esp_task_wdt_init(&cfg);
#elif defined(ESP_IDF_VERSION_MAJOR) && (ESP_IDF_VERSION_MAJOR >= 5)
  esp_task_wdt_config_t cfg = {};
  cfg.timeout_ms = TASK_WDT_TIMEOUT_SECONDS * 1000;
  cfg.trigger_panic = true;
  return esp_task_wdt_init(&cfg);
#else
  return esp_task_wdt_init(TASK_WDT_TIMEOUT_SECONDS, true);
#endif
}

static void init_task_watchdog() {
  esp_err_t err = init_task_wdt_backend();
  if (err == ESP_ERR_INVALID_STATE) {
    // Already initialized with a different timeout; reset and try again.
    esp_task_wdt_deinit();
    err = init_task_wdt_backend();
  }
  if (err != ESP_OK && err != ESP_ERR_INVALID_STATE) {
    Serial.printf("WARN: esp_task_wdt_init failed: %d\n", (int)err);
    return;
  }

  err = esp_task_wdt_add(NULL);
  if (err == ESP_ERR_INVALID_STATE) {
    Serial.println("Task WDT already armed for loop task.");
    return;
  }
  if (err != ESP_OK) {
    Serial.printf("WARN: esp_task_wdt_add failed: %d\n", (int)err);
  } else {
    Serial.printf("Task WDT armed (%ds).\n", TASK_WDT_TIMEOUT_SECONDS);
  }
}

static uint8_t effective_divider(const PidExtra *extra) {
  uint16_t base = extra ? extra->baseDivider : 1;
  uint16_t gov  = extra ? extra->governorDivider : 1;
  if (base == 0) base = 1;
  if (gov == 0) gov = 1;
  uint32_t eff = base * gov;
  if (eff == 0) eff = 1;
  if (eff > 255) eff = 255;
  return static_cast<uint8_t>(eff);
}

static void set_extra_base_divider(PidExtra *extra, uint8_t div, bool resetGovernor) {
  if (!extra) return;
  if (div == 0) div = 1;
  extra->baseDivider = div;
  if (resetGovernor || extra->governorDivider == 0) {
    extra->governorDivider = 1;
  }
  extra->skippedUpdates = 0;
  extra->hasLastPayload = false;
  extra->lastLength = 0;
  memset(extra->lastData, 0, sizeof(extra->lastData));
}

static void apply_divider_to_pidmap(uint16_t pid, uint8_t div, bool resetGovernor = false) {
  PidExtra *extra = pidMap.getOrCreateExtra(pid);
  if (!extra) return;
  set_extra_base_divider(extra, div, resetGovernor);
}

// ===== Deny list (CLI-managed) =====
static const size_t DENY_MAX = 64;
static uint32_t denyList[DENY_MAX];
static size_t   denyCount = 0;

static bool isDenied(uint32_t pid) {
  for (size_t i = 0; i < denyCount; ++i) if (denyList[i] == pid) return true;
  return false;
}
static void addDeny(uint32_t pid) {
  if (isDenied(pid)) return;
  if (denyCount < DENY_MAX) denyList[denyCount++] = pid;
}
static void removeDeny(uint32_t pid) {
  for (size_t i = 0; i < denyCount; ++i) {
    if (denyList[i] == pid) {
      for (size_t j = i + 1; j < denyCount; ++j) denyList[j-1] = denyList[j];
      denyCount--;
      return;
    }
  }
}
static void clearDeny() { denyCount = 0; }

// ===== Profile allow-list =====
using pidmaps::PidRule;

static const pidmaps::PidMapDefinition *CAR_PID_MAP = ACTIVE_PID_MAP;

static inline const pidmaps::PidMapDefinition *active_pid_map() {
  return CAR_PID_MAP;
}

// Toggle: PROFILE allow-list (true) vs sniff-all (false)
static constexpr bool DEFAULT_USE_PROFILE_ALLOWLIST = true;
static bool USE_PROFILE_ALLOWLIST = DEFAULT_USE_PROFILE_ALLOWLIST;

// ======== Oil pressure (analog) ========
#define OIL_ADC_PIN         1       // GPIO1 (ADC1_CH0)
#define ADC_SAMPLES         8
#define ADC_IIR_ALPHA       0.15f
#define ADC_DEADBAND_PSI    0.5f
static constexpr float ADC_VALID_VREF = 3.60f;

// Pressure range
static const float P0_PSI = 0.0f;
static const float P1_PSI = 150.0f;

// Cal endpoints at the ADC pin (defaults; persisted in flash)
static constexpr float DEFAULT_V0_ADC = 0.3482f;   // 0 psi
static constexpr float DEFAULT_V1_ADC = 3.1290f;   // 150 psi
static float V0_ADC = DEFAULT_V0_ADC;   // 0 psi
static float V1_ADC = DEFAULT_V1_ADC;   // 150 psi

// Publish to BLE CAN 0x710
static const uint32_t OIL_CAN_ID      = 0x710;  // private 11-bit
static const uint16_t OIL_SCALE_01PSI = 10;     // 0.1 psi/bit
static uint16_t       OIL_TX_RATE_MS  = 40;     // persisted in flash

// Runtime
static float    oil_psi_f  = 0.0f;
static uint8_t  oil_flags  = 0;      // bit0=open, bit1=short, bit2=oor
static uint32_t lastOilTxMs = 0;

// ===== Flash (Preferences) =====
static Preferences cfgPrefs;   // namespace "cca_cfg"
static constexpr const char *CFG_NAMESPACE = "cca_cfg";
static uint32_t CFG_TOKEN = 0;

static const size_t CUSTOM_DIVIDER_MAX = 64;

struct __attribute__((packed)) CfgPidDivider {
  uint16_t pid;
  uint8_t div;
};

struct __attribute__((packed)) CfgDividerBlob {
  uint16_t count;
  CfgPidDivider items[CUSTOM_DIVIDER_MAX];
};

static CfgPidDivider customDividers[CUSTOM_DIVIDER_MAX];
static uint16_t customDividerCount = 0;

static int find_custom_divider_index(uint16_t pid) {
  for (uint16_t i = 0; i < customDividerCount; ++i) {
    if (customDividers[i].pid == pid) return i;
  }
  return -1;
}

static uint8_t compute_default_divider_for_pid(uint32_t pid) {
  const auto *map = active_pid_map();
  if (map) {
    for (size_t i = 0; i < map->ruleCount; ++i) {
      const PidRule &rule = map->rules[i];
      if (rule.pid == pid) {
        uint8_t div = rule.divider;
        return div == 0 ? 1 : div;
      }
    }
    if (map->policyDividerForId) {
      uint8_t policy = map->policyDividerForId(pid);
      if (policy) return policy;
    }
  }

  if (pid == 0x139) return 1;
  if (pid < 0x100) return 4;
  if (pid < 0x200) return 2;
  if (pid > 0x700) return 1; // OBD replies

  uint8_t div = DEFAULT_UPDATE_RATE_DIVIDER;
  if (!div) div = 1;
  return div;
}

bool piddiv_set(uint16_t pid, uint8_t div) {
  if (div == 0) div = 1;
  int idx = find_custom_divider_index(pid);
  if (idx >= 0) {
    customDividers[idx].div = div;
  } else {
    if (customDividerCount >= CUSTOM_DIVIDER_MAX) return false;
    customDividers[customDividerCount].pid = pid;
    customDividers[customDividerCount].div = div;
    customDividerCount++;
  }
  apply_divider_to_pidmap(pid, div, /*resetGovernor=*/true);
  return true;
}

bool piddiv_clear(uint16_t pid) {
  int idx = find_custom_divider_index(pid);
  if (idx < 0) return false;
  for (uint16_t i = idx + 1; i < customDividerCount; ++i) {
    customDividers[i - 1] = customDividers[i];
  }
  customDividerCount--;
  apply_divider_to_pidmap(pid, compute_default_divider_for_pid(pid), /*resetGovernor=*/true);
  return true;
}

void piddiv_apply_all() {
  for (uint16_t i = 0; i < customDividerCount; ++i) {
    apply_divider_to_pidmap(customDividers[i].pid, customDividers[i].div, /*resetGovernor=*/false);
  }
}

// ===== BLE TX soft governor =====
static constexpr float    BLE_TX_FPS_LIMIT                = 180.0f;
static constexpr uint8_t  BLE_TX_GOVERNOR_MAX_DIVIDER     = 8;
static constexpr uint8_t  BLE_TX_OVER_LIMIT_SECONDS       = 3;
static constexpr uint32_t BLE_TX_OVER_LIMIT_DURATION_MS   = 3000;
static constexpr uint8_t  BLE_TX_RELAX_SECONDS            = 5;
static constexpr uint32_t BLE_TX_RELAX_DURATION_MS        = 5000;
static constexpr uint32_t BLE_TX_GOVERNOR_STEP_INTERVAL_MS = 1000;
static constexpr uint8_t  BLE_TX_HISTORY_SECONDS          = 6;
static bool     bleTxBucketsInitialized = false;
static uint16_t bleTxSecondBuckets[BLE_TX_HISTORY_SECONDS];
static uint8_t  bleTxBucketIndex        = BLE_TX_HISTORY_SECONDS - 1;
static uint8_t  bleTxFilledSeconds      = 0;
static uint16_t bleTxCurrentSecondCount = 0;
static uint32_t bleTxCurrentSecondStartMs = 0;

static float    bleTxMovingAverageFps   = 0.0f;
static uint32_t bleTxOverLimitSinceMs   = 0;
static uint32_t bleTxBelowLimitSinceMs  = 0;
static uint32_t bleTxLastBoostMs        = 0;
static uint32_t bleTxLastRelaxMs        = 0;
static bool     bleGovernorActive       = false;

static size_t capture_governor_snapshot(GovernorSnapshot *out) {
  size_t count = 0;
  pidMap.forEach([&](void *entry) {
    if (count >= BLE_GOVERNOR_SNAPSHOT_MAX) return;
    const PidExtra *extra = pidMap.getExtra(entry);
    if (!extra) return;
    uint8_t gov = extra->governorDivider ? extra->governorDivider : 1;
    if (gov > 1) {
      out[count].pid = pidMap.getPid(entry);
      out[count].governor = gov;
      count++;
    }
  });
  return count;
}

static bool restore_governor_snapshot(const GovernorSnapshot *snapshots, size_t count) {
  bool any = false;
  for (size_t i = 0; i < count; ++i) {
    void *entry = pidMap.getEntryId(snapshots[i].pid);
    if (!entry) continue;
    PidExtra *extra = pidMap.getExtra(entry);
    uint8_t gov = snapshots[i].governor;
    if (gov < 1) gov = 1;
    extra->governorDivider = gov;
    extra->skippedUpdates = 0;
    extra->hasLastPayload = false;
    extra->lastLength = 0;
    memset(extra->lastData, 0, sizeof(extra->lastData));
    if (gov > 1) any = true;
  }
  return any;
}

static void bleTxAdvanceBuckets(uint32_t now) {
  if (!bleTxBucketsInitialized) {
    memset(bleTxSecondBuckets, 0, sizeof(bleTxSecondBuckets));
    bleTxBucketIndex = BLE_TX_HISTORY_SECONDS - 1;
    bleTxFilledSeconds = 0;
    bleTxCurrentSecondCount = 0;
    bleTxCurrentSecondStartMs = now;
    bleTxBucketsInitialized = true;
    return;
  }

  while (now - bleTxCurrentSecondStartMs >= 1000) {
    bleTxBucketIndex = (bleTxBucketIndex + 1) % BLE_TX_HISTORY_SECONDS;
    if (bleTxFilledSeconds < BLE_TX_HISTORY_SECONDS) {
      bleTxFilledSeconds++;
    }
    bleTxSecondBuckets[bleTxBucketIndex] = bleTxCurrentSecondCount;
    bleTxCurrentSecondCount = 0;
    bleTxCurrentSecondStartMs += 1000;
  }
}

static void noteBleTxFrame(uint32_t now) {
  bleTxAdvanceBuckets(now);
  bleTxCurrentSecondCount++;
}

static uint32_t bleTxFramesInRecentSeconds(uint8_t seconds) {
  if (!bleTxBucketsInitialized || bleTxFilledSeconds == 0 || seconds == 0) {
    return 0;
  }
  if (seconds > bleTxFilledSeconds) seconds = bleTxFilledSeconds;
  uint32_t sum = 0;
  for (uint8_t i = 0; i < seconds; ++i) {
    uint8_t idx = (bleTxBucketIndex + BLE_TX_HISTORY_SECONDS - i) % BLE_TX_HISTORY_SECONDS;
    sum += bleTxSecondBuckets[idx];
  }
  return sum;
}

static bool governorIncreaseDividers() {
  bool changed = false;
  pidMap.forEach([&](void *entry) {
    PidExtra *extra = pidMap.getExtra(entry);
    uint8_t eff = effective_divider(extra);
    if (eff < BLE_TX_GOVERNOR_MAX_DIVIDER) {
      uint8_t gov = extra->governorDivider ? extra->governorDivider : 1;
      if (gov < 128) {
        gov *= 2;
        if (gov == 0) gov = 1;
        extra->governorDivider = gov;
        extra->skippedUpdates = 0;
        extra->hasLastPayload = false;
        extra->lastLength = 0;
        memset(extra->lastData, 0, sizeof(extra->lastData));
        changed = true;
      }
    }
  });
  if (changed) bleGovernorActive = true;
  return changed;
}

static bool governorRelaxDividers() {
  bool changed = false;
  bool stillActive = false;
  pidMap.forEach([&](void *entry) {
    PidExtra *extra = pidMap.getExtra(entry);
    uint8_t base = extra->baseDivider ? extra->baseDivider : 1;
    uint8_t eff = effective_divider(extra);
    if (eff > base) {
      uint8_t gov = extra->governorDivider ? extra->governorDivider : 1;
      if (gov > 1) {
        uint8_t newGov = gov / 2;
        if (newGov < 1) newGov = 1;
        extra->governorDivider = newGov;
        extra->skippedUpdates = 0;
        extra->hasLastPayload = false;
        extra->lastLength = 0;
        memset(extra->lastData, 0, sizeof(extra->lastData));
        changed = true;
        eff = effective_divider(extra);
      } else {
        extra->governorDivider = 1;
        eff = effective_divider(extra);
      }
    }
    if (eff > base) {
      stillActive = true;
    }
  });
  bleGovernorActive = stillActive;
  return changed;
}

static void updateBleGovernor(uint32_t now) {
  bleTxAdvanceBuckets(now);

  float avgSeconds = static_cast<float>(bleTxFilledSeconds);
  uint32_t sumCompleted = bleTxFramesInRecentSeconds(bleTxFilledSeconds);
  uint32_t partialMs = 0;
  if (bleTxBucketsInitialized) {
    if (now >= bleTxCurrentSecondStartMs) {
      partialMs = now - bleTxCurrentSecondStartMs;
    }
  }

  float denom = avgSeconds;
  if (partialMs > 0) {
    denom += static_cast<float>(partialMs) / 1000.0f;
  } else if (avgSeconds == 0 && bleTxCurrentSecondCount > 0) {
    denom = 1.0f;
  }

  float totalFrames = static_cast<float>(sumCompleted + bleTxCurrentSecondCount);
  if (denom > 0.0f) bleTxMovingAverageFps = totalFrames / denom;
  else               bleTxMovingAverageFps = 0.0f;

  bool overLimit = false;
  bool belowLimit = false;
  if (bleTxFilledSeconds >= BLE_TX_OVER_LIMIT_SECONDS) {
    float avg = static_cast<float>(bleTxFramesInRecentSeconds(BLE_TX_OVER_LIMIT_SECONDS)) /
                static_cast<float>(BLE_TX_OVER_LIMIT_SECONDS);
    overLimit = (avg > BLE_TX_FPS_LIMIT);
  }
  if (bleTxFilledSeconds >= BLE_TX_RELAX_SECONDS) {
    float avg = static_cast<float>(bleTxFramesInRecentSeconds(BLE_TX_RELAX_SECONDS)) /
                static_cast<float>(BLE_TX_RELAX_SECONDS);
    belowLimit = (avg < BLE_TX_FPS_LIMIT);
  }

  if (overLimit) {
    if (bleTxOverLimitSinceMs == 0) bleTxOverLimitSinceMs = now;
    bleTxBelowLimitSinceMs = 0;
    if ((now - bleTxOverLimitSinceMs) >= BLE_TX_OVER_LIMIT_DURATION_MS &&
        (now - bleTxLastBoostMs) >= BLE_TX_GOVERNOR_STEP_INTERVAL_MS) {
      if (governorIncreaseDividers()) {
        bleTxLastBoostMs = now;
      }
    }
  } else {
    bleTxOverLimitSinceMs = 0;
    if (belowLimit) {
      if (bleTxBelowLimitSinceMs == 0) bleTxBelowLimitSinceMs = now;
      if ((now - bleTxBelowLimitSinceMs) >= BLE_TX_RELAX_DURATION_MS &&
          (now - bleTxLastRelaxMs) >= BLE_TX_GOVERNOR_STEP_INTERVAL_MS) {
        if (governorRelaxDividers()) {
          bleTxLastRelaxMs = now;
        }
      }
    } else {
      bleTxBelowLimitSinceMs = 0;
    }
  }
}

static void bleRecalculateNotifyBudgets() {
  uint16_t maxLen = g_bleNotifyMaxValueLength;
  if (maxLen == 0) {
    g_bleNotifyBurstBudgetPerLoop = 1;
    return;
  }

  uint32_t computed = BLE_NOTIFY_BASE_BUDGET_BYTES / maxLen;
  if (computed == 0) {
    computed = 1;
  }
  if (computed > kBaseCanNotifiesPerLoop) {
    computed = kBaseCanNotifiesPerLoop;
  }
  g_bleNotifyBurstBudgetPerLoop = static_cast<uint16_t>(computed);
}

static void bleResetNotifySizing() {
  g_bleNegotiatedMtu = BLE_ATT_MTU_DFLT;
  g_bleNotifyMaxValueLength = (BLE_ATT_MTU_DFLT > 3) ? (BLE_ATT_MTU_DFLT - 3) : 0;
  bleRecalculateNotifyBudgets();
}

static void bleApplyNegotiatedMtu(uint16_t mtu) {
  if (mtu < BLE_ATT_MTU_DFLT) {
    mtu = BLE_ATT_MTU_DFLT;
  }
  g_bleNegotiatedMtu = mtu;
  g_bleNotifyMaxValueLength = (mtu > 3) ? (mtu - 3) : 0;
  bleRecalculateNotifyBudgets();
}

static void bleNotifyLogClamp(const char *label, size_t requested, size_t allowed) {
  uint32_t now = millis();
  bleNotifyClampEvents++;
  if ((now - bleNotifyClampLastLogMs) < BLE_NOTIFY_CLAMP_LOG_INTERVAL_MS) {
    return;
  }

  Serial.printf("WARN: BLE %s payload clamped (%u -> %u bytes, MTU=%u)\n",
                label ? label : "?",
                static_cast<unsigned>(requested),
                static_cast<unsigned>(allowed),
                static_cast<unsigned>(g_bleNegotiatedMtu));
  bleNotifyClampLastLogMs = now;
}

static uint8_t bleClampCanDataLen(uint8_t requested, const char *label) {
  if (g_bleNotifyMaxValueLength < 4) {
    bleNotifyLogClamp(label, static_cast<size_t>(requested) + 4, g_bleNotifyMaxValueLength);
    return 0;
  }

  uint16_t maxData = g_bleNotifyMaxValueLength - 4;
  if (maxData > 16) {
    maxData = 16;
  }
  if (requested <= maxData) {
    return requested;
  }

  bleNotifyLogClamp(label, static_cast<size_t>(requested) + 4, g_bleNotifyMaxValueLength);
  return static_cast<uint8_t>(maxData & 0xFFu);
}

static size_t bleClampPayloadLength(size_t requested, const char *label) {
  if (g_bleNotifyMaxValueLength == 0) {
    bleNotifyLogClamp(label, requested, 0);
    return 0;
  }
  if (requested <= g_bleNotifyMaxValueLength) {
    return requested;
  }

  size_t allowed = g_bleNotifyMaxValueLength;
  bleNotifyLogClamp(label, requested, allowed);
  return allowed;
}

static uint16_t bleDiagMaxTuplesPerPacket() {
  if (g_bleNotifyMaxValueLength <= 2) {
    return 0;
  }
  return static_cast<uint16_t>((g_bleNotifyMaxValueLength - 2) / 7);
}

static bool bleNotifyIsCongestionCode(int code) {
  switch (code) {
    case BLE_HS_ENOMEM:
    case BLE_HS_EBUSY:
    case BLE_HS_EAGAIN:
    case BLE_HS_ESTALLED:
    case BLE_HS_ECONTROLLER:
    case BLE_HS_ETIMEOUT:
      return true;
    default:
      return false;
  }
}

static uint32_t bleNotifyBackoffDurationForLevel(uint8_t level) {
  if (level == 0) {
    level = 1;
  }
  uint32_t duration = BLE_NOTIFY_BACKOFF_BASE_MS << (level - 1);
  if (duration > BLE_NOTIFY_BACKOFF_MAX_MS) {
    duration = BLE_NOTIFY_BACKOFF_MAX_MS;
  }
  return duration;
}

static void bleNotifyBackoffTrigger(const char *label, int code) {
  uint32_t now = millis();

  if (bleNotifyBackoffActive && static_cast<int32_t>(now - bleNotifyBackoffUntilMs) >= 0) {
    bleNotifyBackoffService(now);
  }

  if (!bleNotifyBackoffActive) {
    bleNotifyBackoffSnapshotCount = capture_governor_snapshot(bleNotifyBackoffSnapshot);
    bleNotifyBackoffActive = true;
    bleNotifyBackoffLevel = 0;
  }

  if (bleNotifyBackoffLevel < BLE_NOTIFY_BACKOFF_MAX_LEVEL) {
    bleNotifyBackoffLevel++;
  }

  uint32_t duration = bleNotifyBackoffDurationForLevel(bleNotifyBackoffLevel);
  bleNotifyBackoffUntilMs = now + duration;
  bleNotifyBackoffEvents++;

  const char *codeStr = NimBLEUtils::returnCodeToString(code);
  snprintf(bleNotifyBackoffLastReason, sizeof(bleNotifyBackoffLastReason),
           "%s:%d%s%s",
           label ? label : "?",
           code,
           (codeStr && codeStr[0]) ? ":" : "",
           (codeStr && codeStr[0]) ? codeStr : "");

  if (governorIncreaseDividers()) {
    bleTxLastBoostMs = now;
  }

  if ((now - bleNotifyBackoffLastLogMs) >= BLE_NOTIFY_BACKOFF_LOG_INTERVAL_MS) {
    Serial.printf("WARN: BLE notify backoff level=%u duration=%lu ms reason=%s\n",
                  static_cast<unsigned>(bleNotifyBackoffLevel),
                  static_cast<unsigned long>(duration),
                  bleNotifyBackoffLastReason);
    bleNotifyBackoffLastLogMs = now;
  }
}

static void bleNotifyBackoffReset() {
  if (bleNotifyBackoffSnapshotCount > 0) {
    bool any = restore_governor_snapshot(bleNotifyBackoffSnapshot, bleNotifyBackoffSnapshotCount);
    bleGovernorActive = any;
  }
  bleNotifyBackoffSnapshotCount = 0;
  bleNotifyBackoffActive = false;
  bleNotifyBackoffLevel = 0;
  bleNotifyBackoffUntilMs = 0;
  bleNotifyBackoffLastLogMs = 0;
  snprintf(bleNotifyBackoffLastReason, sizeof(bleNotifyBackoffLastReason), "none");
}

static void bleNotifyBackoffService(uint32_t now) {
  if (!bleNotifyBackoffActive) {
    return;
  }
  if (static_cast<int32_t>(now - bleNotifyBackoffUntilMs) < 0) {
    return;
  }

  if (bleNotifyBackoffSnapshotCount > 0) {
    bool any = restore_governor_snapshot(bleNotifyBackoffSnapshot, bleNotifyBackoffSnapshotCount);
    bleGovernorActive = any;
  }
  bleNotifyBackoffSnapshotCount = 0;
  bleNotifyBackoffActive = false;
  bleNotifyBackoffLevel = 0;
  bleNotifyBackoffUntilMs = 0;
  snprintf(bleNotifyBackoffLastReason, sizeof(bleNotifyBackoffLastReason), "idle");
}

static void bleNotifyHandleFailure(const char *label, int code) {
  uint32_t now = millis();
  bleNotifyFailuresTotal++;
  bleNotifyLastStatusCode = code;
  bleNotifyLastStatusMs = now;

  bool congested = bleNotifyIsCongestionCode(code);
  if (congested) {
    bleNotifyCongestionEvents++;
  }

  if ((now - bleNotifyFailureLastLogMs) >= BLE_NOTIFY_FAILURE_LOG_INTERVAL_MS) {
    const char *codeStr = NimBLEUtils::returnCodeToString(code);
    Serial.printf("WARN: BLE notify %s failed (%d %s)\n",
                  label ? label : "?",
                  code,
                  codeStr ? codeStr : "?");
    bleNotifyFailureLastLogMs = now;
  }

  bleNotifyBackoffTrigger(label, congested ? code : BLE_HS_EUNKNOWN);
}

void bleHandleNotifyStatus(const char *label, int code) {
  uint32_t now = millis();
  bleNotifyLastStatusCode = code;
  bleNotifyLastStatusMs = now;

  if (code == 0 || code == BLE_HS_EDONE) {
    return;
  }

  bleNotifyStatusErrors++;
  bool congested = bleNotifyIsCongestionCode(code);
  if (congested) {
    bleNotifyCongestionEvents++;
  }

  if ((now - bleNotifyFailureLastLogMs) >= BLE_NOTIFY_FAILURE_LOG_INTERVAL_MS) {
    const char *codeStr = NimBLEUtils::returnCodeToString(code);
    Serial.printf("WARN: BLE notify status %s -> %d %s\n",
                  label ? label : "?",
                  code,
                  codeStr ? codeStr : "?");
    bleNotifyFailureLastLogMs = now;
  }

  if (congested) {
    bleNotifyBackoffTrigger(label, code);
  }
}

static bool bleNotifyCharacteristic(NimBLECharacteristic* characteristic,
                                    const char *label,
                                    uint32_t now,
                                    bool countTxFrame) {
  if (!characteristic || !bleIsConnected()) {
    return false;
  }

  if (!characteristic->notify()) {
    bleNotifyHandleFailure(label, BLE_HS_EUNKNOWN);
    return false;
  }

  if (countTxFrame) {
    noteBleTxFrame(now);
  }
  return true;
}

// ===== BLE helpers we provide (instead of RaceChronoBle.*) =====
static inline bool bleIsConnected(){
  return g_server && g_server->getConnectedCount() > 0;
}

static void bleStartAdvertising(){
  if (!g_adv) return;
  g_adv->start();
  refreshBleLed();
  led_service(millis());
}

static void bleStopAdvertising(){
  if (!g_adv) return;
  g_adv->stop();
  refreshBleLed();
  led_service(millis());
}

static void refreshBleLed() {
  LedPattern pattern = LedPattern::BlinkFast;
  if (bleIsConnected()) {
    pattern = LedPattern::Solid;
  }
  led_set_ble(pattern);
}

static void resetStatusIndicatorsForDisconnect() {
  have_seen_any_can = false;
  lastCanMessageReceivedMs = 0;
  gpsMarkSentenceStale();

  led_set_power(LedPattern::Solid);
  led_set_ble(LedPattern::BlinkFast);
  led_set_can(LedPattern::BlinkSlow);
  led_set_gps(LedPattern::BlinkSlow);
  led_set_sys(LedPattern::Off);
  led_set_oil(LedPattern::Off);
}

// ===== FIL (0x0002) handler to mirror RaceChrono DIY control =====
static void handleFilWrite(const uint8_t *d, size_t L) {
  if (!d || L < 1) return;

  uint8_t cmd = d[0];
  const uint8_t *payload = nullptr;
  size_t payloadLen = 0;

#if DEV_TRUST_FIL
  if (L > 1) {
    payload = d + 1;
    payloadLen = L - 1;
  }
#else
  uint32_t now = millis();
  if (filWriteWindowStartMs == 0 || (now - filWriteWindowStartMs) > FIL_WRITE_WINDOW_MS) {
    filWriteWindowStartMs = now;
    filWritesInWindow = 0;
  }
  if (filWritesInWindow >= FIL_WRITE_WINDOW_MAX) {
    Serial.println("FIL: throttled (rate limit)");
    return;
  }
  filWritesInWindow++;

  if (CFG_TOKEN == 0) {
    Serial.println("FIL: token unavailable; ignoring write");
    return;
  }
  if (L < 5) {
    Serial.println("FIL: ignoring write (token missing)");
    return;
  }
  uint32_t token = ((uint32_t)d[1] << 24) |
                   ((uint32_t)d[2] << 16) |
                   ((uint32_t)d[3] << 8) |
                   ((uint32_t)d[4]);
  if (token != CFG_TOKEN) {
    Serial.println("FIL: bad token; ignoring write");
    return;
  }
  payload = d + 5;
  payloadLen = L - 5;
#endif

  switch (cmd) {
    case 0: { // Deny all
      Serial.println("FIL: DENY ALL -> keeping profile allow-list");
      resetSkippedUpdatesCounters();
      break;
    }
    case 1: { // Allow all + interval
      uint16_t interval = 0;
      if (payloadLen >= 2 && payload) {
        interval = ((uint16_t)payload[0] << 8) | payload[1];
      }
      Serial.printf("FIL: ALLOW ALL (interval=%ums)\n", (unsigned)interval);
      clearDeny();
      break;
    }
    case 2: { // Allow one PID (minimal accept)
      if (!payload || payloadLen < 6) {
        Serial.println("FIL: ALLOW PID (ignored; packet too short)");
        break;
      }
      uint32_t pid = ((uint32_t)payload[0]) |
                     ((uint32_t)payload[1] << 8) |
                     ((uint32_t)payload[2] << 16) |
                     ((uint32_t)payload[3] << 24);
      uint16_t interval = ((uint16_t)payload[4] << 8) | payload[5];
      Serial.printf("FIL: ALLOW PID 0x%03lX (interval=%ums)\n",
                    static_cast<unsigned long>(pid),
                    (unsigned)interval);

      removeDeny(pid);

      if (USE_PROFILE_ALLOWLIST) {
        pidMap.allowOnePid(pid, interval);
        if (PidExtra *extra = pidMap.getOrCreateExtra(pid)) {
          uint8_t base = compute_default_divider_for_pid(pid);
          if (base == 0) base = 1;
          set_extra_base_divider(extra, base, /*resetGovernor=*/true);
        }
      }
      break;
    }
    default:
      break;
  }
}

class FilCB : public NimBLECharacteristicCallbacks {
public:
  void onWrite(NimBLECharacteristic* ch){
    std::string v = ch->getValue();
    handleFilWrite((const uint8_t*)v.data(), v.size());
  }
  void onWrite(NimBLECharacteristic* ch, ble_gap_conn_desc*){
    std::string v = ch->getValue();
    handleFilWrite((const uint8_t*)v.data(), v.size());
  }
#if defined(NIMBLE_CPP_IDF) || defined(ARDUINO_ARCH_ESP32)
  void onWrite(NimBLECharacteristic* ch, NimBLEConnInfo&){
    std::string v = ch->getValue();
    handleFilWrite((const uint8_t*)v.data(), v.size());
  }
#endif
} g_filCB;

class NotifyStatusCB : public NimBLECharacteristicCallbacks {
 public:
  explicit NotifyStatusCB(const char *label) : label_(label) {}

  void onStatus(NimBLECharacteristic*, int code) override {
    bleHandleNotifyStatus(label_, code);
  }

 private:
  const char *label_;
};

static NotifyStatusCB g_canNotifyCB{"CAN"};
static NotifyStatusCB g_gpsNotifyCB{"GPS"};
static NotifyStatusCB g_gtmNotifyCB{"GTM"};
static NotifyStatusCB g_diagNotifyCB{"DIAG"};

// ===== Our CAN sender over BLE 0x0001 =====
static uint8_t canBuf[20];
static int bleSendCanData(uint32_t pid, const uint8_t *data, uint8_t len) {
  if (!g_can || !bleIsConnected()) {
    return -1;
  }

  if (g_bleNotifyMaxValueLength < 4) {
    bleNotifyLogClamp("CAN", static_cast<size_t>(len) + 4, g_bleNotifyMaxValueLength);
    return -1;
  }

  uint8_t allowed = bleClampCanDataLen(len, "CAN");

  canBuf[0] = static_cast<uint8_t>(pid & 0xFFu);
  canBuf[1] = static_cast<uint8_t>((pid >> 8) & 0xFFu);
  canBuf[2] = static_cast<uint8_t>((pid >> 16) & 0xFFu);
  canBuf[3] = static_cast<uint8_t>((pid >> 24) & 0xFFu);

  if (allowed && data) {
    memcpy(&canBuf[4], data, allowed);
  }

  uint32_t now = millis();
  g_can->setValue(canBuf, 4 + allowed);
  if (!bleNotifyCharacteristic(g_can, "CAN", now, true)) {
    return -1;
  }

  return static_cast<int>(allowed);
}

// ===== GPS helpers =====
static inline int clampi(int value, int lo, int hi) {
  return value < lo ? lo : (value > hi ? hi : value);
}

static inline uint32_t msSinceMidnightFromTime(int hour, int minute, int second, int millis) {
  uint32_t h = static_cast<uint32_t>(hour >= 0 ? hour : 0);
  uint32_t m = static_cast<uint32_t>(minute >= 0 ? minute : 0);
  uint32_t s = static_cast<uint32_t>(second >= 0 ? second : 0);
  uint32_t ms = static_cast<uint32_t>(millis >= 0 ? millis : 0);
  uint64_t total = (static_cast<uint64_t>(h) * MS_PER_HOUR) +
                   (static_cast<uint64_t>(m) * MS_PER_MINUTE) +
                   (static_cast<uint64_t>(s) * MS_PER_SECOND) +
                   static_cast<uint64_t>(ms);
  return static_cast<uint32_t>(total % MS_PER_DAY);
}

static int64_t gpsComputeMonotonicUs(uint32_t micros_now, int64_t correction_us) {
  if (!rmc_time_available) {
    return static_cast<int64_t>(gps_monotonic_ms) * 1000LL;
  }

  uint32_t base_capture_us = rmc_capture_tick_us;
  uint32_t delta_us = micros_now - base_capture_us;
  int64_t base_us = static_cast<int64_t>(rmc_ms_since_midnight) * 1000LL;
  int64_t candidate_us = base_us + static_cast<int64_t>(delta_us) + correction_us;

  candidate_us %= GPS_US_PER_DAY;
  if (candidate_us < 0) {
    candidate_us += GPS_US_PER_DAY;
  }

  return candidate_us;
}

static uint32_t gpsMonotonicMsSinceMidnight(uint32_t now) {
  (void)now;

  if (!rmc_time_available) {
    return gps_monotonic_ms;
  }

  uint32_t now_us = micros();
  int64_t candidate_us = gpsComputeMonotonicUs(now_us, gps_time_correction_us);
  uint32_t candidate = static_cast<uint32_t>(candidate_us / 1000LL);

  if (candidate < gps_monotonic_ms) {
    uint32_t diff = gps_monotonic_ms - candidate;
    if (diff < 2000) {
      candidate = gps_monotonic_ms;
    } else if (diff < (MS_PER_DAY - 2000)) {
      candidate = gps_monotonic_ms;
    }
  }

  gps_monotonic_ms = candidate;
  return gps_monotonic_ms;
}

static void parseRmcSentence(char *line) {
  gps::RmcData rmc;
  if (!gps::parseRmcSentence(line, rmc)) return;

  if (rmc.has_time) {
    rmc_hour = rmc.hour;
    rmc_min  = rmc.minute;
    rmc_sec  = rmc.second;
    rmc_millis = rmc.millis;
  }

  uint32_t msSinceMidnight = msSinceMidnightFromTime(rmc_hour, rmc_min, rmc_sec, rmc_millis);
  rmc_ms_since_midnight = msSinceMidnight;
  uint32_t capture_ms = millis();
  uint32_t capture_us = micros();
  rmc_capture_tick_ms = capture_ms;
  rmc_capture_tick_us = capture_us;
  if (!rmc_time_available) {
    gps_monotonic_ms = msSinceMidnight;
    rmc_time_available = true;
  }

  rmc_valid = rmc.valid;

  if (rmc.has_latitude) rmc_lat_deg = rmc.latitude_deg;
  if (rmc.has_longitude) rmc_lon_deg = rmc.longitude_deg;

  rmc_speed_kmh = rmc.speed_kmh;
  rmc_course_deg = rmc.course_deg;

  if (rmc.has_date) {
    gps_day = rmc.day;
    gps_mon = rmc.month;
    gps_year = rmc.year;
  }
}

static void parseGgaSentence(char *line) {
  gps::GgaData gga;
  if (!gps::parseGgaSentence(line, gga)) return;

  gga_sats = gga.has_sats ? gga.sats : 0;
  gga_hdop = gga.has_hdop ? gga.hdop : 99.9;
  gga_alt_m = gga.has_altitude ? gga.altitude_m : 0.0;
}

// ===== BLE bring-up (we own the whole 0x1FF8 service) =====
static void bleInit(){
  NimBLEDevice::init(DEVICE_NAME);
  NimBLEDevice::setPower(ESP_PWR_LVL_P9);
  NimBLEDevice::setMTU(185);
#if !DEV_TRUST_FIL
  NimBLEDevice::setSecurityAuth(true, true, true);
  NimBLEDevice::setSecurityPasskey(PASSKEY_U32);
#endif

  g_server = NimBLEDevice::createServer();
  bleLinkPri_attachIfReady();

  g_svc = g_server->createService(RC_SERVICE_UUID);

  g_can = g_svc->createCharacteristic(RC_CHAR_CAN_UUID,
            NIMBLE_PROPERTY::READ | NIMBLE_PROPERTY::NOTIFY);
  uint16_t filProps = NIMBLE_PROPERTY::WRITE;
#if !DEV_TRUST_FIL
  filProps |= NIMBLE_PROPERTY::WRITE_ENC;
#endif
  g_fil = g_svc->createCharacteristic(RC_CHAR_FIL_UUID, filProps);
  g_gps = g_svc->createCharacteristic(RC_CHAR_GPS_UUID,
            NIMBLE_PROPERTY::READ | NIMBLE_PROPERTY::NOTIFY);
  g_gtm = g_svc->createCharacteristic(RC_CHAR_GTM_UUID,
            NIMBLE_PROPERTY::READ | NIMBLE_PROPERTY::NOTIFY);
  g_diag = g_svc->createCharacteristic(RC_CHAR_DIAG_UUID,
            NIMBLE_PROPERTY::READ | NIMBLE_PROPERTY::NOTIFY);

  g_can->setCallbacks(&g_canNotifyCB);
  g_fil->setCallbacks(&g_filCB);
  g_gps->setCallbacks(&g_gpsNotifyCB);
  g_gtm->setCallbacks(&g_gtmNotifyCB);
  g_diag->setCallbacks(&g_diagNotifyCB);

  // Init payloads
  { uint8_t init20[20]; memset(init20, 0xFF, sizeof(init20)); g_gps->setValue(init20, 20); }
  { uint8_t init3[3] = {0,0,0}; g_gtm->setValue(init3, 3); }
  { uint8_t init2[2] = {0,0}; g_diag->setValue(init2, 2); }

  g_svc->start();

  g_adv = NimBLEDevice::getAdvertising();
  g_adv->addServiceUUID(RC_SERVICE_UUID);
  bleStartAdvertising();

  Serial.println("BLE: advertising (RaceChrono DIY 0x1FF8)");
}

// Pack & notify GPS frames on our g_gps/g_gtm
static void gpsPackAndNotify(uint32_t now) {
  if (!bleIsConnected() || !g_gps || !g_gtm) return;

  uint8_t payload[20];
  memset(payload, 0xFF, sizeof(payload));

  uint32_t msSinceMidnight = gpsMonotonicMsSinceMidnight(now);
  uint32_t msIntoHour = msSinceMidnight % MS_PER_HOUR;
  int hour = static_cast<int>((msSinceMidnight / MS_PER_HOUR) % 24);
  int year = gps_year >= 2000 ? gps_year : 2000;
  int month = gps_mon >= 1 ? gps_mon : 1;
  int day = gps_day >= 1 ? gps_day : 1;
  int dateHour = ((year - 2000) * 8928) + ((month - 1) * 744) + ((day - 1) * 24) + hour;
  if (dateHour != lastDateHourPacked) {
    lastDateHourPacked = dateHour;
    gpsSyncBits = (gpsSyncBits + 1) & 0x7;
  }

  int timeSinceHour = static_cast<int>(msIntoHour / 2);
  if (timeSinceHour < 0) timeSinceHour = 0;

  uint8_t fixQuality = rmc_valid ? 1 : 0;
  uint8_t sats = static_cast<uint8_t>(clampi(gga_sats, 0, 63));

  int32_t latFixed = static_cast<int32_t>(lround(rmc_lat_deg * 10000000.0));
  int32_t lonFixed = static_cast<int32_t>(lround(rmc_lon_deg * 10000000.0));

  int altWord = 0xFFFF;
  if (gga_alt_m > -7000.0 && gga_alt_m < 20000.0) {
    double alt = gga_alt_m;
    if (alt >= -500.0 && alt <= 6053.5) {
      altWord = clampi(static_cast<int>(lround((alt + 500.0) * 10.0)) & 0x7FFF, 0, 0x7FFF);
    } else {
      altWord = (static_cast<int>(lround(alt + 500.0)) & 0x7FFF) | 0x8000;
    }
  }

  int speedWord = 0xFFFF;
  double speed = rmc_speed_kmh;
  if (speed <= 655.35) {
    speedWord = clampi(static_cast<int>(lround(speed * 100.0)) & 0x7FFF, 0, 0x7FFF);
  } else {
    speedWord = (static_cast<int>(lround(speed * 10.0)) & 0x7FFF) | 0x8000;
  }

  int bearing = clampi(static_cast<int>(lround(rmc_course_deg * 100.0)), 0, 0xFFFF);
  uint8_t hdop = (gga_hdop >= 0.0 && gga_hdop <= 25.4) ? static_cast<uint8_t>(lround(gga_hdop * 10.0)) : 0xFF;
  uint8_t vdop = 0xFF;

  payload[0]  = static_cast<uint8_t>(((gpsSyncBits & 0x7) << 5) | ((timeSinceHour >> 16) & 0x1F));
  payload[1]  = static_cast<uint8_t>(timeSinceHour >> 8);
  payload[2]  = static_cast<uint8_t>(timeSinceHour);
  payload[3]  = static_cast<uint8_t>(((fixQuality & 0x3) << 6) | (sats & 0x3F));
  payload[4]  = static_cast<uint8_t>(latFixed >> 24);
  payload[5]  = static_cast<uint8_t>(latFixed >> 16);
  payload[6]  = static_cast<uint8_t>(latFixed >> 8);
  payload[7]  = static_cast<uint8_t>(latFixed);
  payload[8]  = static_cast<uint8_t>(lonFixed >> 24);
  payload[9]  = static_cast<uint8_t>(lonFixed >> 16);
  payload[10] = static_cast<uint8_t>(lonFixed >> 8);
  payload[11] = static_cast<uint8_t>(lonFixed);
  payload[12] = static_cast<uint8_t>(altWord >> 8);
  payload[13] = static_cast<uint8_t>(altWord);
  payload[14] = static_cast<uint8_t>(speedWord >> 8);
  payload[15] = static_cast<uint8_t>(speedWord);
  payload[16] = static_cast<uint8_t>(bearing >> 8);
  payload[17] = static_cast<uint8_t>(bearing);
  payload[18] = hdop;
  payload[19] = vdop;

  size_t gpsLen = bleClampPayloadLength(sizeof(payload), "GPS");
  if (gpsLen > 0) {
    g_gps->setValue(payload, gpsLen);
    bleNotifyCharacteristic(g_gps, "GPS", now, true);
  }

  uint8_t timePayload[3];
  timePayload[0] = static_cast<uint8_t>(((gpsSyncBits & 0x7) << 5) | ((dateHour >> 16) & 0x1F));
  timePayload[1] = static_cast<uint8_t>(dateHour >> 8);
  timePayload[2] = static_cast<uint8_t>(dateHour);
  size_t gtmLen = bleClampPayloadLength(sizeof(timePayload), "GTM");
  if (gtmLen > 0) {
    g_gtm->setValue(timePayload, gtmLen);
    bleNotifyCharacteristic(g_gtm, "GTM", now, true);
  }
}

static void gpsSendRaw(const char *cmd) {
  GPSSerial.print(cmd);
}

static bool gpsScanForNmea(size_t maxBytes = 96) {
  size_t processed = 0;
  while (GPSSerial.available() && processed < maxBytes) {
    char c = static_cast<char>(GPSSerial.read());
    processed++;
    if (gpsInitPrevWasDollar) {
      gpsInitPrevWasDollar = (c == '$');
      if (c == 'G' || c == 'N') {
        return true;
      }
    } else {
      gpsInitPrevWasDollar = (c == '$');
    }
  }
  return false;
}

static void gpsDrainInput(size_t maxBytes = 128) {
  size_t processed = 0;
  while (GPSSerial.available() && processed < maxBytes) {
    GPSSerial.read();
    processed++;
  }
}

static void gpsResetSyncState() {
  gpsSyncBits = 0;
  lastDateHourPacked = -1;
  lastGpsNotifyMs = 0;
  rmc_time_available = false;
  rmc_ms_since_midnight = 0;
  rmc_capture_tick_ms = millis();
  rmc_capture_tick_us = micros();
  gps_monotonic_ms = 0;
#if GPS_PPS_GPIO >= 0
  gps_time_correction_us = 0;
  gps_pps_locked = false;
  gps_pps_drift_estimate_us = 0.0;
  noInterrupts();
  gps_pps_event_count = 0;
  gps_pps_last_isr_micros = 0;
  interrupts();
#endif
}

static void gpsMarkSentenceStale() {
  gpsLastSentenceMs = 0;
  rmc_valid = false;
}

static void gpsHandlePpsDiscipline(uint32_t now_ms) {
#if GPS_PPS_GPIO >= 0
  uint32_t eventMicros = 0;
  uint32_t intervalUs = 0;
  bool haveEvent = false;

  noInterrupts();
  if (gps_pps_event_count > 0) {
    gps_pps_event_count = 0;
    eventMicros = gps_pps_event_micros;
    intervalUs = gps_pps_last_interval_us;
    haveEvent = true;
  }
  interrupts();

  if (!haveEvent) {
    return;
  }

  if (!rmc_time_available) {
    gps_pps_locked = false;
    return;
  }

  if (intervalUs >= GPS_PPS_DEBOUNCE_US && intervalUs <= 2000000) {
    double diff = static_cast<double>(intervalUs) - 1000000.0;
    gps_pps_drift_estimate_us += 0.05 * (diff - gps_pps_drift_estimate_us);
  }

  int64_t candidate_us = gpsComputeMonotonicUs(eventMicros, gps_time_correction_us);
  int64_t rounded_us = ((candidate_us + 500000LL) / 1000000LL) * 1000000LL;
  if (rounded_us >= GPS_US_PER_DAY) {
    rounded_us -= GPS_US_PER_DAY;
  }

  int64_t error_us = rounded_us - candidate_us;
  if (error_us > (GPS_US_PER_DAY / 2)) {
    error_us -= GPS_US_PER_DAY;
  } else if (error_us < -(GPS_US_PER_DAY / 2)) {
    error_us += GPS_US_PER_DAY;
  }

  int64_t adjust_us = error_us;
  if (adjust_us > GPS_PPS_MAX_SLEW_US) {
    adjust_us = GPS_PPS_MAX_SLEW_US;
  } else if (adjust_us < -GPS_PPS_MAX_SLEW_US) {
    adjust_us = -GPS_PPS_MAX_SLEW_US;
  }

  gps_time_correction_us += adjust_us;

  int64_t correction_limit = GPS_US_PER_DAY / 2;
  if (gps_time_correction_us > correction_limit) {
    gps_time_correction_us = correction_limit;
  } else if (gps_time_correction_us < -correction_limit) {
    gps_time_correction_us = -correction_limit;
  }

  gpsMonotonicMsSinceMidnight(now_ms);

  gps_pps_locked = true;
  gps_pps_last_processed_ms = now_ms;
#else
  (void)now_ms;
#endif
}

static void gpsBeginInitAttempt(uint32_t now, bool resetAttemptCounter) {
  Serial.printf("[GPS] UART init @ %u bps (RX=%d, TX=%d)\n", 9600u, GPS_RX_GPIO, GPS_TX_GPIO);
  GPSSerial.end();
  gpsInitProbeIndex = 0;
  gpsInitCurrentBaud = GPS_INIT_PROBE_BAUDS[gpsInitProbeIndex];
  GPSSerial.begin(gpsInitCurrentBaud, SERIAL_8N1, GPS_RX_GPIO, GPS_TX_GPIO);
  gpsInitPrevWasDollar = false;
  gpsInitSawInitialNmea = false;
  gpsInitFallbackBaud = gpsInitCurrentBaud;
  gpsInitCommandIndex = 0;
  gpsInitPhase = GpsInitPhase::WaitInitialNmea;
  gpsInitPhaseStartMs = now;
  gpsUsingRawStream = false;
  gpsResetSyncState();
  gpsMarkSentenceStale();
  if (resetAttemptCounter) {
    gpsInit115200Attempt = 0;
  }
}

static void gpsFinalizeConfigured(uint32_t now) {
  gpsConfigured = true;
  gpsUsingRawStream = false;
  gpsWarnedNoNmea = false;
  gpsLastSentenceMs = now;
  gpsResetSyncState();
  Serial.println("[GPS] Configured: RMC+GGA @10Hz, 115200");
  gpsInitPhase = GpsInitPhase::Idle;
  gpsInit115200Attempt = 0;
}

static void gpsFinalizeRawStream(uint32_t now) {
  gpsConfigured = true;
  gpsUsingRawStream = true;
  gpsLastSentenceMs = now;
  gpsResetSyncState();
  gpsInit115200Attempt = 0;
  if (!gpsInitSawInitialNmea) {
    gpsInitFallbackBaud = GPS_INIT_PROBE_BAUDS[0];
    if (!gpsWarnedNoNmea) {
      Serial.println("[GPS] No NMEA detected; using raw stream");
      gpsWarnedNoNmea = true;
    }
  } else {
    Serial.printf("[GPS] Using raw stream (baud switch not acknowledged, %lu bps)\n",
                  static_cast<unsigned long>(gpsInitFallbackBaud));
  }
  gpsInitPhase = GpsInitPhase::Idle;
}

static void gpsInitStep(uint32_t now) {
  switch (gpsInitPhase) {
    case GpsInitPhase::Idle:
      if (now - lastGpsInitAttemptMs >= GPS_INIT_RETRY_MS) {
        lastGpsInitAttemptMs = now;
        gpsBeginInitAttempt(now, true);
      }
      break;

    case GpsInitPhase::WaitInitialNmea:
      if (gpsScanForNmea()) {
        gpsInitSawInitialNmea = true;
        gpsInitFallbackBaud = gpsInitCurrentBaud;
        Serial.printf("[GPS] Detected NMEA @ %lu\n", static_cast<unsigned long>(gpsInitCurrentBaud));
        gpsInitPhase = GpsInitPhase::SendConfigCommand;
        gpsInitPhaseStartMs = now;
      } else if (now - gpsInitPhaseStartMs >= 500) {
        if ((gpsInitProbeIndex + 1) < GPS_INIT_PROBE_BAUD_COUNT) {
          gpsInitProbeIndex++;
          gpsInitCurrentBaud = GPS_INIT_PROBE_BAUDS[gpsInitProbeIndex];
          gpsDrainInput();
          GPSSerial.updateBaudRate(gpsInitCurrentBaud);
          gpsInitPrevWasDollar = false;
          gpsInitPhaseStartMs = now;
        } else {
          gpsInitPhase = GpsInitPhase::SendConfigCommand;
          gpsInitPhaseStartMs = now;
        }
      }
      break;

    case GpsInitPhase::SendConfigCommand: {
      static const char *CMDS[] = {
        PMTK_SET_NMEA_OUTPUT_RMCGGA,
        PMTK_SET_NMEA_UPDATE_10HZ,
        PMTK_SET_BAUD_115200,
      };
      static constexpr size_t CMD_COUNT = sizeof(CMDS) / sizeof(CMDS[0]);
      if (gpsInitCommandIndex < CMD_COUNT) {
        gpsSendRaw(CMDS[gpsInitCommandIndex]);
        gpsInitCommandIndex++;
        gpsInitPhase = GpsInitPhase::CommandDelay;
        gpsInitPhaseStartMs = now;
      } else {
        gpsInitPhase = GpsInitPhase::Prepare115200;
        gpsInitPhaseStartMs = now;
      }
      break;
    }

    case GpsInitPhase::CommandDelay:
      if (now - gpsInitPhaseStartMs >= 90) {
        gpsInitPhase = GpsInitPhase::SendConfigCommand;
        gpsInitPhaseStartMs = now;
      }
      break;

    case GpsInitPhase::Prepare115200:
      gpsDrainInput();
      GPSSerial.end();
      gpsInitPrevWasDollar = false;
      gpsInitPhase = GpsInitPhase::WaitBefore115200;
      gpsInitPhaseStartMs = now;
      break;

    case GpsInitPhase::WaitBefore115200:
      if (now - gpsInitPhaseStartMs >= GPS_WAIT_BEFORE_115200_MS) {
        GPSSerial.begin(115200, SERIAL_8N1, GPS_RX_GPIO, GPS_TX_GPIO);
        gpsInitPrevWasDollar = false;
        gpsInitPhase = GpsInitPhase::Confirm115200;
        gpsInitPhaseStartMs = now;
      }
      break;

    case GpsInitPhase::Confirm115200:
      if (gpsScanForNmea()) {
        gpsFinalizeConfigured(now);
      } else if (now - gpsInitPhaseStartMs >= GPS_CONFIRM_115200_TIMEOUT_MS) {
        GPSSerial.end();
        gpsInit115200Attempt++;
        if (gpsInit115200Attempt < GPS_INIT_MAX_115200_ATTEMPTS) {
          Serial.printf("[GPS] 115200 confirm timeout, retrying (%u/%u)\n",
                        static_cast<unsigned>(gpsInit115200Attempt),
                        static_cast<unsigned>(GPS_INIT_MAX_115200_ATTEMPTS));
          gpsBeginInitAttempt(now, false);
        } else {
          Serial.println("[GPS] 115200 confirm failed, using raw stream");
          gpsInitPhase = GpsInitPhase::BeginFallback;
          gpsInitPhaseStartMs = now;
        }
      }
      break;

    case GpsInitPhase::BeginFallback:
      if (now - gpsInitPhaseStartMs >= 20) {
        GPSSerial.begin(gpsInitFallbackBaud, SERIAL_8N1, GPS_RX_GPIO, GPS_TX_GPIO);
        gpsInitPrevWasDollar = false;
        gpsInitPhase = GpsInitPhase::FinalizeFallback;
        gpsInitPhaseStartMs = now;
      }
      break;

    case GpsInitPhase::FinalizeFallback:
      gpsFinalizeRawStream(now);
      break;
  }
}

static void gpsProcessSentence(char *line) {
  if (!line || strlen(line) < 6) return;
  if (strstr(line, "GPRMC") || strstr(line, "GNRMC")) {
    parseRmcSentence(line);
  } else if (strstr(line, "GPGGA") || strstr(line, "GNGGA")) {
    parseGgaSentence(line);
  }
}

static void gpsService(uint32_t now) {
  if (!gpsConfigured) {
    gpsMarkSentenceStale();
    gpsInitStep(now);
    if (!gpsConfigured) {
      return;
    }
  }

  bool sentenceSeen = false;
  while (GPSSerial.available()) {
    char c = static_cast<char>(GPSSerial.read());
    if (c == '\r') continue;
    if (c == '\n') {
      gpsLineBuf[gpsLineLen] = 0;
      if (gpsLineLen > 0 && gpsLineBuf[0] == '$') {
        char work[sizeof(gpsLineBuf)];
        strncpy(work, gpsLineBuf, sizeof(work) - 1);
        work[sizeof(work) - 1] = 0;
        gpsProcessSentence(work);
        sentenceSeen = true;
      }
      gpsLineLen = 0;
    } else {
      if (gpsLineLen < sizeof(gpsLineBuf) - 1) {
        gpsLineBuf[gpsLineLen++] = c;
      } else {
        gpsLineLen = 0;
      }
    }
  }

  uint32_t serviceNow = millis();

  gpsHandlePpsDiscipline(serviceNow);

  if (sentenceSeen) {
    gpsLastSentenceMs = serviceNow;
  } else {
    uint32_t timeoutMs = gpsUsingRawStream ? 5000 : 2000;
    if (serviceNow - gpsLastSentenceMs > timeoutMs) {
      if (gpsUsingRawStream) {
        Serial.println("[GPS] Raw stream stalled -> retry config");
      } else {
        Serial.println("[GPS] Sentence timeout -> reinit");
      }
      gpsConfigured = false;
      gpsUsingRawStream = false;
      gpsWarnedNoNmea = false;
      gpsResetSyncState();
      gpsMarkSentenceStale();
      GPSSerial.end();
      lastGpsInitAttemptMs = serviceNow;
      return;
    }
  }

  if (bleIsConnected()) {
    uint32_t notifyNow = serviceNow;
    if (every(notifyNow, &lastGpsNotifyMs, GPS_NOTIFY_PERIOD_MS)) {
      gpsPackAndNotify(notifyNow);
    }
  }
}

static void clear_custom_dividers() {
  customDividerCount = 0;
  memset(customDividers, 0, sizeof(customDividers));
}

static uint32_t generate_cfg_token() {
  uint32_t token = 0;
  while (token == 0) {
    token = esp_random();
  }
  return token;
}

static bool save_cfg_token_value(uint32_t token) {
  if (!cfgPrefs.begin(CFG_NAMESPACE, false)) return false;
  ScopedNvsWrite guard;
  bool ok = cfgPrefs.putUInt("token", token) == sizeof(uint32_t);
  cfgPrefs.end();
  return ok;
}

static void cfg_apply_runtime_defaults() {
  V0_ADC = DEFAULT_V0_ADC;
  V1_ADC = DEFAULT_V1_ADC;
  USE_PROFILE_ALLOWLIST = DEFAULT_USE_PROFILE_ALLOWLIST;
  clear_custom_dividers();
}

bool cfg_load_from_nvs() {
  bool calibrationLoaded = oil_calibration_load(&V0_ADC, &V1_ADC);
  if (!calibrationLoaded) {
    V0_ADC = DEFAULT_V0_ADC;
    V1_ADC = DEFAULT_V1_ADC;
  }

  bool anyLoaded = calibrationLoaded;
  bool needSaveToken = false;
  if (!cfgPrefs.begin(CFG_NAMESPACE, true)) return anyLoaded;

  customDividerCount = 0;

  if (cfgPrefs.isKey("token")) {
    uint32_t stored = cfgPrefs.getUInt("token", 0);
    if (stored != 0) {
      CFG_TOKEN = stored;
    } else {
      needSaveToken = true;
    }
  } else {
    needSaveToken = true;
  }

  if (!calibrationLoaded) {
    bool legacyLoaded = false;
    if (cfgPrefs.isKey("v0_adc")) {
      float v0 = cfgPrefs.getFloat("v0_adc", V0_ADC);
      if (v0 >= 0.0f && v0 < 3.5f) {
        V0_ADC = v0;
        legacyLoaded = true;
      }
    }
    if (cfgPrefs.isKey("v1_adc")) {
      float v1 = cfgPrefs.getFloat("v1_adc", V1_ADC);
      if (v1 > V0_ADC && v1 < 3.6f) {
        V1_ADC = v1;
        legacyLoaded = true;
      }
    }
    if (legacyLoaded) {
      anyLoaded = true;
      oil_calibration_save(V0_ADC, V1_ADC);
    }
  }
  if (cfgPrefs.isKey("profile")) {
    uint8_t prof = cfgPrefs.getUChar("profile", USE_PROFILE_ALLOWLIST ? 1 : 0);
    USE_PROFILE_ALLOWLIST = (prof != 0);
    anyLoaded = true;
  }

  size_t blobLen = cfgPrefs.getBytesLength("dividers");
  if (blobLen >= sizeof(uint16_t)) {
    CfgDividerBlob blob;
    memset(&blob, 0, sizeof(blob));
    size_t readLen = cfgPrefs.getBytes("dividers", &blob, sizeof(blob));
    if (readLen >= sizeof(uint16_t)) {
      uint16_t count = blob.count;
      if (count > CUSTOM_DIVIDER_MAX) count = CUSTOM_DIVIDER_MAX;
      for (uint16_t i = 0; i < count; ++i) {
        uint16_t pid = blob.items[i].pid;
        uint8_t div = blob.items[i].div == 0 ? 1 : blob.items[i].div;
        customDividers[customDividerCount].pid = pid;
        customDividers[customDividerCount].div = div;
        customDividerCount++;
      }
      anyLoaded = true;
    }
  }

  cfgPrefs.end();
  if (needSaveToken) {
    CFG_TOKEN = generate_cfg_token();
    if (!save_cfg_token_value(CFG_TOKEN)) {
      Serial.println("CFG: failed to persist new FIL token");
    } else {
      Serial.printf("CFG: generated FIL token %08lX\n", (unsigned long)CFG_TOKEN);
    }
  }
  return anyLoaded;
}

bool cfg_save_to_nvs() {
  bool calOk = oil_calibration_save(V0_ADC, V1_ADC);
  if (!cfgPrefs.begin(CFG_NAMESPACE, false)) return false;

  ScopedNvsWrite guard;

  bool allOk = calOk;
  if (cfgPrefs.putUChar("profile", USE_PROFILE_ALLOWLIST ? 1 : 0) != sizeof(uint8_t)) allOk = false;
  if (cfgPrefs.putUInt("token", CFG_TOKEN) != sizeof(uint32_t)) allOk = false;

  CfgDividerBlob blob;
  memset(&blob, 0, sizeof(blob));
  blob.count = customDividerCount;
  for (uint16_t i = 0; i < customDividerCount; ++i) {
    blob.items[i] = customDividers[i];
  }
  if (customDividerCount < CUSTOM_DIVIDER_MAX) {
    memset(&blob.items[customDividerCount], 0,
           sizeof(CfgPidDivider) * (CUSTOM_DIVIDER_MAX - customDividerCount));
  }
  size_t written = cfgPrefs.putBytes("dividers", &blob, sizeof(blob));
  if (written != sizeof(blob)) allOk = false;

  cfgPrefs.end();
  return allOk;
}

bool cfg_reset_to_defaults() {
  cfg_apply_runtime_defaults();

  bool calOk = oil_calibration_save(V0_ADC, V1_ADC);

  if (!cfgPrefs.begin(CFG_NAMESPACE, false)) return false;
  ScopedNvsWrite guard;
  cfgPrefs.clear();
  CFG_TOKEN = generate_cfg_token();
  bool tokenOk = cfgPrefs.putUInt("token", CFG_TOKEN) == sizeof(uint32_t);
  cfgPrefs.end();
  if (!tokenOk) {
    Serial.println("CFG: failed to persist FIL token after reset");
  }
  return calOk && tokenOk;
}

static void apply_profile_and_dividers();

void cfg_boot_load_and_apply() {
  bool loaded = cfg_load_from_nvs();
  if (!loaded) {
    cfg_apply_runtime_defaults();
  }

  apply_profile_and_dividers();
}

static twai_filter_config_t build_profile_twai_filter() {
  twai_filter_config_t defaults = TWAI_FILTER_CONFIG_ACCEPT_ALL();
  twai_filter_config_t out = defaults;

  // Force dual-filter mode so both profile-generated specs are evaluated whenever we
  // populate two acceptance windows.
#if defined(TWAI_FILTER_MODE_DUAL)
  out.single_filter = static_cast<decltype(out.single_filter)>(TWAI_FILTER_MODE_DUAL);
#else
  out.single_filter = static_cast<decltype(out.single_filter)>(false);
#endif

  return out;
}

// ===== Forward decls =====
static bool startCanBusReader();
static void stopCanBusReader();
static bool restartCanBusReader(const char *cause = nullptr, uint32_t backoffMs = 50);
static void handleCanFault(const char *cause, uint32_t backoffMs = 50);
static bool checkCanBusHealth(uint32_t now);
[[maybe_unused]] static void noteCanWriteResult(bool success);
[[maybe_unused]] static bool writeFrameWithWatch(CanFrame &frame, uint32_t timeout = 1);
static void setLastReconnectCause(const char *reason);

static void bufferNewPacket(const CanFrame &frame, uint32_t t_us_rx);
static void handleBufferedPacketsBurst(uint32_t budget_us = 2000);
static void logNotifyCapIfNeeded(uint32_t now);
static void flushBufferedPackets();
static void sendCanDiagnostics(uint32_t now);
static int bleSendCanData(uint32_t pid, const uint8_t *data, uint8_t len);
static void diagRecordFrame(uint32_t pid, uint8_t dlc, uint32_t t_us_rx);
static void serviceDiagStream();

static void apply_allow_list_profile();
static void apply_allow_all();
static void apply_profile_and_dividers();

bool cfg_load_from_nvs();
bool cfg_save_to_nvs();
bool cfg_reset_to_defaults();
bool piddiv_set(uint16_t pid, uint8_t div);
bool piddiv_clear(uint16_t pid);
void piddiv_apply_all();
void cfg_boot_load_and_apply();

static float  filtered_adc_volts();
static uint8_t oil_health_flags_from_volts(float v);
static float  volts_to_psi_exact(float v);
static void   oil_update_and_publish_if_due();

static void   restartBle(const char *reason = nullptr);
static void   process_cli_line(char *line);
static void   show_config();      // concise SHOW
static void   show_stats();       // SHOW STATS
static void   dumpMapToSerial();  // verbose only on SHOW MAP
static void   dumpDenyToSerial(); // verbose only on SHOW DENY

// ===== Clean BLE restart (no deinit; advertiser stop/start only) =====
static void restartBle(const char *reason) {
  if (reason && reason[0]) {
    setLastReconnectCause(reason);
  }
  Serial.println("BLE: restart...");
  bleNotifyBackoffReset();
  bleStopAdvertising();
  // Service + characteristics remain; we just restart advertising.
  bleStartAdvertising();
  Serial.println("BLE: advertising");
  led_service(millis());
}

// ===== Setup =====
void setup() {
  Serial.begin(115200);
  uint32_t t0 = millis(); while (!Serial && millis() - t0 < 3000) {}

  Serial.printf("FW: %s\n", FW_VERSION_STRING);
  esp_reset_reason_t reason = esp_reset_reason();
  Serial.printf("Boot reason: %s (%d)\n", reset_reason_to_string(reason), (int)reason);

  init_task_watchdog();

  led_init();
  led_set_power(LedPattern::Solid);
  led_set_ble(LedPattern::BlinkFast);
  led_set_oil(LedPattern::Off);
  led_service(millis());

  // ADC
  analogReadResolution(12);
  analogSetPinAttenuation(OIL_ADC_PIN, ADC_11db);
  pinMode(OIL_ADC_PIN, INPUT);

  // BLE
  Serial.println("BLE setup...");
  bleResetNotifySizing();
  bleInit();
  Serial.println("RaceChrono connection will establish in background.");

  setLastReconnectCause("boot");

  // Load persisted config + apply profile/dividers
  cfg_boot_load_and_apply();

  show_config(); // one-time concise boot print

#if GPS_PPS_GPIO >= 0
  pinMode(GPS_PPS_GPIO, INPUT);
  attachInterrupt(GPS_PPS_GPIO, gpsPpsIsr, RISING);
  Serial.printf("[GPS] PPS discipline enabled on GPIO %d\n", GPS_PPS_GPIO);
#endif

  // GPS
  uint32_t gpsStartMs = millis();
  gpsBeginInitAttempt(gpsStartMs, true);
  lastGpsInitAttemptMs = gpsStartMs;

  // CAN bring-up deferred to loop() retry logic
}

static void recoverRaceChronoConnection(const char *reason) {
  Serial.println("RC disconnected -> reset map + CAN + BLE.");
  pidMap.reset();
  stopCanBusReader();

  restartBle(reason);
  Serial.println("Advertising for new RaceChrono connection (non-blocking).");

  gpsResetSyncState();

  apply_profile_and_dividers();

  lastCanDiagSendMs = 0;
  sendCanDiagnostics(millis());
}

static void queueBleRestart(const char *reason) {
  if (pendingBleRestart) return;
  const char *src = (reason && reason[0]) ? reason : "RC disconnect";
  strncpy(pendingBleRestartReason, src, sizeof(pendingBleRestartReason) - 1);
  pendingBleRestartReason[sizeof(pendingBleRestartReason) - 1] = '\0';
  pendingBleRestart = true;
}

static void servicePendingBleRestart() {
  if (!pendingBleRestart) return;
  if (nvsWriteInProgress) return;

  pendingBleRestart = false;
  recoverRaceChronoConnection(pendingBleRestartReason[0] ? pendingBleRestartReason : nullptr);
  pendingBleRestartReason[0] = '\0';
}

// ===== CAN bring-up/teardown =====
static bool startCanBusReader() {
  Serial.println("TWAI start...");
  ESP32Can.setPins(CAN_TX, CAN_RX);
  ESP32Can.setSpeed(ESP32Can.convertSpeed(500));
  ESP32Can.setRxQueueSize(64);
  ESP32Can.setTxQueueSize(16);
  twai_filter_config_t profileFilter = build_profile_twai_filter();
  if (!ESP32Can.begin(ESP32Can.getSpeed(), CAN_TX, CAN_RX, 0xFFFF, 0xFFFF, &profileFilter)) {
    Serial.println("ERROR: TWAI begin() failed. Check wiring/termination/RS.");
    return false;
  }
  Serial.println("CAN OK.");
  isCanBusReaderActive = true;
  have_seen_any_can = false;
  uint32_t nowMs = millis();
  lastCanMessageReceivedMs = nowMs;
  lastCanRestartMs = nowMs;
  lastTwaiStatus.state = TWAI_STATE_RUNNING;
  lastTwaiStatus.tx_error_counter = 0;
  lastTwaiStatus.rx_error_counter = 0;
  lastTwaiStatus.bus_error_count = 0;
  return true;
}

static void stopCanBusReader() {
  ESP32Can.end();
  isCanBusReaderActive = false;
  lastCanStatusCheckMs = 0;
  canTxFailureWindowStart = 0;
  canTxFailuresInWindow = 0;
  lastTwaiStatus.state = TWAI_STATE_STOPPED;
  lastTwaiStatus.tx_error_counter = 0;
  lastTwaiStatus.rx_error_counter = 0;
  lastTwaiStatus.bus_error_count = 0;
}

static void setLastReconnectCause(const char *reason) {
  const char *src = (reason && reason[0]) ? reason : "unknown";
  strncpy(lastReconnectCause, src, sizeof(lastReconnectCause) - 1);
  lastReconnectCause[sizeof(lastReconnectCause) - 1] = '\0';
}

static bool restartCanBusReader(const char *cause, uint32_t backoffMs) {
  if (cause && cause[0]) {
    Serial.printf("CAN: restart (%s)\n", cause);
    setLastReconnectCause(cause);
  } else {
    Serial.println("CAN: restart");
    setLastReconnectCause("CAN restart");
  }

  stopCanBusReader();
  uint32_t waitStart = millis();
  while (millis() - waitStart < backoffMs) {
    led_service(millis());
    delay(20);
  }

  bool started = startCanBusReader();
  if (started) {
    flushBufferedPackets();
    resetSkippedUpdatesCounters();
    lastCanMessageReceivedMs = millis();
    canRestartCount++;
    lastCanDiagSendMs = 0;
    lastCanRestartMs = millis();
  }

  return started;
}

static void handleCanFault(const char *cause, uint32_t backoffMs) {
  char reason[64];
  if (cause && cause[0]) {
    strncpy(reason, cause, sizeof(reason) - 1);
    reason[sizeof(reason) - 1] = '\0';
  } else {
    strncpy(reason, "CAN fault", sizeof(reason) - 1);
    reason[sizeof(reason) - 1] = '\0';
  }

  Serial.printf("ERROR: %s -> restart CAN\n", reason);
  num_can_bus_timeouts++;
  lastCanDiagSendMs = 0;
  sendCanDiagnostics(millis());
  restartCanBusReader(reason, backoffMs);
}

static bool checkCanBusHealth(uint32_t now) {
  if (!isCanBusReaderActive) return false;
  if ((now - lastCanStatusCheckMs) < CAN_STATUS_POLL_INTERVAL_MS) return false;

  lastCanStatusCheckMs = now;

  twai_status_info_t status;
  if (twai_get_status_info(&status) != ESP_OK) {
    return false;
  }

  lastTwaiStatus = status;

  if (status.state == TWAI_STATE_BUS_OFF) {
    canBusOffCount++;
    char reason[64];
    snprintf(reason, sizeof(reason),
             "TWAI bus-off (tx_err=%u rx_err=%u)",
             (unsigned)status.tx_error_counter,
             (unsigned)status.rx_error_counter);
    handleCanFault(reason, CAN_RECOVERY_BACKOFF_MS);
    return true;
  }

  if (status.state == TWAI_STATE_STOPPED) {
    handleCanFault("TWAI stopped");
    return true;
  }

  return false;
}

[[maybe_unused]] static void noteCanWriteResult(bool success) {
  if (success) {
    canTxFailuresInWindow = 0;
    canTxFailureWindowStart = 0;
    return;
  }

  uint32_t now = millis();
  if ((canTxFailureWindowStart == 0) ||
      (now - canTxFailureWindowStart > CAN_TX_FAILURE_WINDOW_MS)) {
    canTxFailureWindowStart = now;
    canTxFailuresInWindow = 0;
  }

  canTxFailuresInWindow++;
  if (canTxFailuresInWindow >= CAN_TX_FAILURE_THRESHOLD) {
    char reason[64];
    snprintf(reason, sizeof(reason),
             "CAN TX failure window (%u/%ums)",
             (unsigned)canTxFailuresInWindow,
             (unsigned)CAN_TX_FAILURE_WINDOW_MS);
    handleCanFault(reason);
    canTxFailureWindowStart = 0;
    canTxFailuresInWindow = 0;
  }
}

[[maybe_unused]] static bool writeFrameWithWatch(CanFrame &frame, uint32_t timeout) {
  bool ok = ESP32Can.writeFrame(frame, timeout);
  noteCanWriteResult(ok);
  return ok;
}

// ===== Helpers =====
static inline float clampf(float x, float lo, float hi) {
  return x < lo ? lo : (x > hi ? hi : x);
}

static uint8_t oil_health_flags_from_volts(float v) {
  const float OPEN_THR  = V1_ADC + 0.10f;
  const float SHORT_THR = 0.05f;
  uint8_t f = 0;
  if (v > OPEN_THR)  f |= (1 << 0);
  if (v < SHORT_THR) f |= (1 << 1);
  if (v < V0_ADC - 0.08f || v > V1_ADC + 0.08f) f |= (1 << 2);
  return f;
}

// Median-of-5 then IIR
static float filtered_adc_volts() {
  float s[5];
  for (int i = 0; i < 5; i++) {
#if defined(ESP_ARDUINO_VERSION_MAJOR) && (ESP_ARDUINO_VERSION_MAJOR >= 3)
    s[i] = analogReadMilliVolts(OIL_ADC_PIN) / 1000.0f;
#else
    uint32_t acc = 0;
    for (int k = 0; k < ADC_SAMPLES; k++) acc += analogRead(OIL_ADC_PIN);
    const float ADC_VREF = 3.30f, ADC_MAX = 4095.0f;
    s[i] = ((acc / (float)ADC_SAMPLES) * ADC_VREF) / ADC_MAX;
#endif
  }
  for (int i=1;i<5;i++){ float t=s[i]; int j=i-1; while(j>=0&&s[j]>t){s[j+1]=s[j]; j--;} s[j+1]=t; }
  float med = s[2];
  static float v_filt = DEFAULT_V0_ADC;
  static bool have_valid = false;
  if (!have_valid) {
    v_filt = DEFAULT_V0_ADC;
  }
  if (isnan(med) || med < 0.0f || med > ADC_VALID_VREF) {
    return v_filt;
  }
  if (!have_valid) {
    v_filt = med;
    have_valid = true;
    return v_filt;
  }
  v_filt = (1.0f - ADC_IIR_ALPHA) * v_filt + ADC_IIR_ALPHA * med;
  return v_filt;
}

// Two-point exact mapping with gentle end snapping
static float volts_to_psi_exact(float v) {
  const float FLOOR_V_MARGIN = 0.020f;
  const float CEIL_V_MARGIN  = 0.010f;
  if (v <= V0_ADC + FLOOR_V_MARGIN) return P0_PSI;
  if (v >= V1_ADC - CEIL_V_MARGIN)  return P1_PSI;
  const float m = (P1_PSI - P0_PSI) / (V1_ADC - V0_ADC);
  float psi = P0_PSI + m * (v - V0_ADC);
  psi = clampf(psi, P0_PSI, P1_PSI);
  if (psi < (P0_PSI + ADC_DEADBAND_PSI)) psi = P0_PSI;
  if (psi > (P1_PSI - ADC_DEADBAND_PSI)) psi = P1_PSI;
  return psi;
}

// ===== Circular buffer =====
struct BufferedMessage {
  CanFrame frame;
  uint32_t t_us_rx;
};
static_assert(alignof(CanFrame) >= alignof(uint32_t), "CanFrame alignment insufficient for fast path");
static constexpr size_t NUM_BUFFERS = 256;
static BufferedMessage buffers[NUM_BUFFERS];
static uint32_t bufferToWriteTo = 0;
static uint32_t bufferToReadFrom = 0;
static uint32_t lastBufferOverflowWarningMs = 0;

struct DiagTuple {
  uint16_t id11;
  uint8_t  dlc;
  uint32_t t_us32;
};
static constexpr size_t DIAG_BUFFER_CAPACITY = 512;
static constexpr size_t DIAG_MAX_TUPLES_PER_PACKET = 26;
static constexpr uint32_t DIAG_NOTIFY_INTERVAL_US = 250000;
static DiagTuple diagBuffer[DIAG_BUFFER_CAPACITY];
static uint32_t diagWriteIndex = 0;
static uint32_t diagReadIndex = 0;
static uint32_t diagLastNotifyUs = 0;
static bool diagTimerInitialized = false;
static uint8_t diagPayload[2 + (DIAG_MAX_TUPLES_PER_PACKET * 7)];
static constexpr uint8_t CAN_RX_FASTPATH_MAX_DLC = 4;

static constexpr uint32_t CAN_RX_READ_BUDGET_US = 2000;      // microseconds per poll burst
static constexpr uint32_t CAN_RX_BUDGET_CHECK_INTERVAL = 16; // frames between budget checks

static inline uint32_t bufferedPacketCount() {
  return bufferToWriteTo - bufferToReadFrom;
}

static inline uint32_t diagBufferedCount() {
  return diagWriteIndex - diagReadIndex;
}

static void bufferNewPacket(const CanFrame &frame, uint32_t t_us_rx) {
  if (bufferedPacketCount() == static_cast<uint32_t>(NUM_BUFFERS)) {
    uint32_t nowMs = millis();
    if (nowMs - lastBufferOverflowWarningMs >= 250) {
      Serial.println("WARNING: RX buffer overflow, dropping oldest.");
      lastBufferOverflowWarningMs = nowMs;
    }
    bufferToReadFrom++;
  }

  BufferedMessage *m = &buffers[bufferToWriteTo % NUM_BUFFERS];
  m->frame = frame;
  if (m->frame.data_length_code > 8) {
    m->frame.data_length_code = 8;
  }
  m->t_us_rx = t_us_rx;
  bufferToWriteTo++;
}

static void diagRecordFrame(uint32_t pid, uint8_t dlc, uint32_t t_us_rx) {
  if (diagBufferedCount() == static_cast<uint32_t>(DIAG_BUFFER_CAPACITY)) {
    diagReadIndex++;
  }
  DiagTuple *slot = &diagBuffer[diagWriteIndex % DIAG_BUFFER_CAPACITY];
  slot->id11 = static_cast<uint16_t>(pid & 0x7FFu);
  slot->dlc = dlc;
  slot->t_us32 = t_us_rx;
  diagWriteIndex++;
}

static void serviceDiagStream() {
  if (!g_diag || !bleIsConnected()) {
    diagTimerInitialized = false;
    return;
  }

  uint32_t nowUs = micros();
  if (!diagTimerInitialized) {
    diagTimerInitialized = true;
    diagLastNotifyUs = nowUs;
  }

  if ((uint32_t)(nowUs - diagLastNotifyUs) < DIAG_NOTIFY_INTERVAL_US) {
    return;
  }

  diagLastNotifyUs = nowUs;

  uint32_t available = diagBufferedCount();
  if (available == 0) {
    diagPayload[0] = 0;
    diagPayload[1] = 0;
    size_t sendLen = bleClampPayloadLength(2, "DIAG");
    if (sendLen > 0) {
      g_diag->setValue(diagPayload, sendLen);
      bleNotifyCharacteristic(g_diag, "DIAG", millis(), false);
    }
    return;
  }

  do {
    available = diagBufferedCount();
    if (!available) break;

    uint16_t maxTuples = bleDiagMaxTuplesPerPacket();
    if (maxTuples > DIAG_MAX_TUPLES_PER_PACKET) {
      maxTuples = DIAG_MAX_TUPLES_PER_PACKET;
    }
    if (maxTuples == 0) {
      diagPayload[0] = 0;
      diagPayload[1] = 0;
      size_t sendLen = bleClampPayloadLength(2, "DIAG");
      if (sendLen == 0) {
        return;
      }
      g_diag->setValue(diagPayload, sendLen);
      bleNotifyCharacteristic(g_diag, "DIAG", millis(), false);
      return;
    }

    uint16_t count = static_cast<uint16_t>(available > maxTuples ? maxTuples : available);

    diagPayload[0] = static_cast<uint8_t>(count & 0xFF);
    diagPayload[1] = static_cast<uint8_t>((count >> 8) & 0xFF);

    size_t payloadLen = 2;
    for (uint16_t i = 0; i < count; ++i) {
      const DiagTuple &tuple = diagBuffer[(diagReadIndex + i) % DIAG_BUFFER_CAPACITY];
      size_t base = payloadLen;
      diagPayload[base + 0] = static_cast<uint8_t>(tuple.id11 & 0xFF);
      diagPayload[base + 1] = static_cast<uint8_t>((tuple.id11 >> 8) & 0x07);
      diagPayload[base + 2] = tuple.dlc;
      uint32_t t = tuple.t_us32;
      diagPayload[base + 3] = static_cast<uint8_t>(t & 0xFF);
      diagPayload[base + 4] = static_cast<uint8_t>((t >> 8) & 0xFF);
      diagPayload[base + 5] = static_cast<uint8_t>((t >> 16) & 0xFF);
      diagPayload[base + 6] = static_cast<uint8_t>((t >> 24) & 0xFF);
      payloadLen += 7;
    }

    diagReadIndex += count;
    g_diag->setValue(diagPayload, payloadLen);
    if (!bleNotifyCharacteristic(g_diag, "DIAG", millis(), false)) {
      return;
    }
  } while (diagBufferedCount() > 0);
}

class Supervisor {
public:
  enum class Subsystem : uint8_t {
    CanPoll = 0,
    GpsService = 1,
    BleBurst = 2,
    Count = 3,
  };

  struct Channel {
    const char *tag;
    uint32_t budgetUs;
    uint32_t streak;
    uint32_t faults;
    uint32_t lastUs;
    uint32_t maxUs;
  };

  Supervisor()
      : channels{
            {"CAN", 2000, 0, 0, 0, 0},
            {"GPS", 3000, 0, 0, 0, 0},
            {"BLE", 4000, 0, 0, 0, 0},
        } {}

  void beginLoop() { loopCounter++; }

  void noteElapsed(Subsystem subsystem, uint32_t elapsedUs) {
    Channel &ch = channels[static_cast<size_t>(subsystem)];
    ch.lastUs = elapsedUs;
    if (elapsedUs > ch.maxUs) {
      ch.maxUs = elapsedUs;
    }

    if (loopCounter <= kStartupGraceLoops) {
      ch.streak = 0;
      return;
    }

    if (elapsedUs <= ch.budgetUs) {
      ch.streak = 0;
      return;
    }

    if (ch.streak < 0xFFFFFFFFu) {
      ch.streak++;
    }

    if (ch.streak > kOverrunTripLoops) {
      if (ch.faults < 0xFFFFFFFFu) {
        ch.faults++;
      }
      emitStarve(ch, elapsedUs);
      ch.streak = 0;
    }
  }

  const Channel &stats(Subsystem subsystem) const {
    return channels[static_cast<size_t>(subsystem)];
  }

private:
  static constexpr uint32_t kStartupGraceLoops = 128;
  static constexpr uint32_t kOverrunTripLoops = 3;
  uint32_t loopCounter = 0;
  static constexpr size_t kChannelCount = static_cast<size_t>(Subsystem::Count);
  Channel channels[kChannelCount];

  void emitStarve(const Channel &ch, uint32_t elapsedUs) {
    char code = ch.tag && ch.tag[0] ? ch.tag[0] : '?';
    uint32_t elapsedMs = (elapsedUs + 500) / 1000;
    if (elapsedMs == 0 && elapsedUs > 0) {
      elapsedMs = 1;
    }

    char text[16];
    int written = snprintf(text, sizeof(text), "STARVE %c,%lu", code, (unsigned long)elapsedMs);
    if (written <= 0) {
      return;
    }
    if (written >= static_cast<int>(sizeof(text))) {
      written = sizeof(text) - 1;
    }

    Serial.printf("WARN: Supervisor STARVE %s (%lu us)\n", ch.tag ? ch.tag : "?", (unsigned long)elapsedUs);
    bleSendCanData(0x777, reinterpret_cast<const uint8_t*>(text), static_cast<uint8_t>(written));
  }
};

static Supervisor g_supervisor;

static void handleBufferedPacketsBurst(uint32_t budget_us) {
  uint32_t t0 = micros();
  uint32_t baseBudget = budget_us ? budget_us : 1;
  uint32_t extendedBudget = baseBudget;
  bool catchUpMode = false;

  while (bufferToReadFrom != bufferToWriteTo) {
    BufferedMessage *m = &buffers[bufferToReadFrom % NUM_BUFFERS];

    diagRecordFrame(m->frame.identifier, m->frame.data_length_code, m->t_us_rx);

    void *entry = pidMap.getEntryId(m->frame.identifier);
    if (!USE_PROFILE_ALLOWLIST && !entry) {
      if (PidExtra *extra = pidMap.getOrCreateExtra(m->frame.identifier)) {
        uint8_t base = compute_default_divider_for_pid(m->frame.identifier);
        set_extra_base_divider(extra, base, /*resetGovernor=*/false);
        entry = pidMap.getEntryId(m->frame.identifier);
      }
    }

    bool allowed = false;
    if (USE_PROFILE_ALLOWLIST) {
      allowed = (entry != nullptr) && !isDenied(m->frame.identifier);
    } else {
      allowed = !isDenied(m->frame.identifier);
    }

    if (allowed) {
      PidExtra *extra = entry ? pidMap.getExtra(entry) : nullptr;
      uint8_t div = extra ? effective_divider(extra) : 1;
      bool dataChanged = false;
      if (extra) {
        uint8_t allowedLen = m->frame.data_length_code;
        if (g_bleNotifyMaxValueLength < 4) {
          allowedLen = 0;
        } else {
          uint16_t maxData = g_bleNotifyMaxValueLength - 4;
          if (maxData > 16) {
            maxData = 16;
          }
          if (allowedLen > maxData) {
            allowedLen = static_cast<uint8_t>(maxData & 0xFFu);
          }
        }

        if (!extra->hasLastPayload || extra->lastLength != allowedLen) {
          dataChanged = true;
        } else if (allowedLen &&
                   memcmp(extra->lastData, m->frame.data, allowedLen) != 0) {
          dataChanged = true;
        }
      }

      bool shouldSend = (!extra) || dataChanged || (extra->skippedUpdates == 0);
      bool sent = false;
      int sentLen = -1;
      if (shouldSend) {
        if (canNotifiesThisLoop >= g_bleNotifyBurstBudgetPerLoop) {
          if (!notifyCapHitCurrentLoop) {
            notifyCapHitCurrentLoop = true;
            notifyCapHitsSinceLastLog++;
          }
          notifies_suppressed_total++;
          break;
        }
        sentLen = bleSendCanData(m->frame.identifier, m->frame.data, m->frame.data_length_code);
        sent = (sentLen >= 0);
        if (sent) {
          canNotifiesThisLoop++;
          if (extra) {
            extra->hasLastPayload = true;
            extra->lastLength = static_cast<uint8_t>(sentLen & 0xFF);
            if (sentLen > 0) {
              size_t copyLen = static_cast<size_t>(sentLen);
              memcpy(extra->lastData, m->frame.data, copyLen);
              if (copyLen < sizeof(extra->lastData)) {
                memset(extra->lastData + copyLen, 0, sizeof(extra->lastData) - copyLen);
              }
            } else {
              memset(extra->lastData, 0, sizeof(extra->lastData));
            }
          }
        } else {
          if (extra) {
            extra->skippedUpdates = 0;
          }
          break;
        }
      }

      if (extra) {
        if (shouldSend) {
          extra->skippedUpdates = sent ? 1 : 0;
        } else {
          extra->skippedUpdates++;
        }
        if (extra->skippedUpdates >= div) {
          extra->skippedUpdates = 0;
        }
      }
    }

    bufferToReadFrom++;

    uint32_t elapsed = micros() - t0;
    if (!catchUpMode) {
      if (elapsed >= baseBudget) {
        if (bufferedPacketCount() > (static_cast<uint32_t>(NUM_BUFFERS) / 2)) {
          catchUpMode = true;
          uint32_t scaled = baseBudget * 4;
          extendedBudget = (scaled > baseBudget) ? scaled : 0xFFFFFFFFu;
        } else {
          break;
        }
      }
    } else {
      if (bufferedPacketCount() <= (static_cast<uint32_t>(NUM_BUFFERS) / 4)) {
        break;
      }
      if (elapsed >= extendedBudget) {
        break;
      }
    }
  }
}

static void logNotifyCapIfNeeded(uint32_t now) {
  if (!notifyCapHitsSinceLastLog) {
    return;
  }
  if ((now - notifyCapLastLogMs) < NOTIFY_CAP_LOG_INTERVAL_MS) {
    return;
  }
  Serial.printf("INFO: CAN notify cap hit %u loop%s (max %u/loop); suppressed_total=%lu\n",
                (unsigned)notifyCapHitsSinceLastLog,
                (notifyCapHitsSinceLastLog == 1) ? "" : "s",
                (unsigned)g_bleNotifyBurstBudgetPerLoop,
                (unsigned long)notifies_suppressed_total);
  notifyCapLastLogMs = now;
  notifyCapHitsSinceLastLog = 0;
}

static void flushBufferedPackets() {
  bufferToWriteTo = 0;
  bufferToReadFrom = 0;
  lastBufferOverflowWarningMs = 0;
  diagWriteIndex = 0;
  diagReadIndex = 0;
  diagTimerInitialized = false;
}

static bool isNimblePoolName(const char *name) {
  if (!name || !name[0]) {
    return false;
  }
  if (strstr(name, "transport_") != nullptr) {
    return true;
  }
  if (strstr(name, "ble_") != nullptr) {
    return true;
  }
  if (strstr(name, "nimble") != nullptr) {
    return true;
  }
  return false;
}

static void captureNimblePoolWatermark(NimblePoolWatermark *watermark) {
  if (!watermark) {
    return;
  }
  *watermark = NimblePoolWatermark{0, 0};
  uint32_t lowestBytes = 0xFFFFFFFFu;
  struct os_mempool *mp = nullptr;
  struct os_mempool_info info = {};

  while ((mp = os_mempool_info_get_next(mp, &info)) != nullptr) {
    if (!isNimblePoolName(info.omi_name)) {
      continue;
    }
    if (info.omi_block_size == 0) {
      continue;
    }

    uint32_t minBlocks = info.omi_min_free;
    uint32_t blockSize = info.omi_block_size;
    uint32_t totalBytes = 0;

    if (minBlocks == 0) {
      totalBytes = 0;
    } else if (blockSize > 0 && minBlocks > (0xFFFFFFFFu / blockSize)) {
      totalBytes = 0xFFFFFFFFu;
    } else {
      totalBytes = minBlocks * blockSize;
    }

    if (totalBytes < lowestBytes) {
      lowestBytes = totalBytes;
      watermark->minFreeBlocks = static_cast<uint16_t>(minBlocks > 0xFFFFu ? 0xFFFFu : minBlocks);
      watermark->blockSize = static_cast<uint16_t>(blockSize > 0xFFFFu ? 0xFFFFu : blockSize);
      if (lowestBytes == 0) {
        break;
      }
    }
  }

  if (lowestBytes == 0xFFFFFFFFu) {
    watermark->minFreeBlocks = 0;
    watermark->blockSize = 0;
  }
}

static void sendCanDiagnostics(uint32_t now) {
  if (!bleIsConnected()) return;
  if (!every(now, &lastCanDiagSendMs, CAN_DIAG_NOTIFY_INTERVAL_MS)) return;

  twai_status_info_t status = lastTwaiStatus;
  if (twai_get_status_info(&status) == ESP_OK) {
    lastTwaiStatus = status;
  } else {
    status = lastTwaiStatus;
  }

  uint32_t heapFreeBytes = esp_get_free_heap_size();
  uint32_t heapMinBytes = esp_get_minimum_free_heap_size();
  uint32_t heapFreeUnits = heapFreeBytes >> 5;  // 32-byte units
  uint32_t heapMinUnits = heapMinBytes >> 5;
  if (heapFreeUnits > 0xFFFFu) heapFreeUnits = 0xFFFFu;
  if (heapMinUnits > 0xFFFFu) heapMinUnits = 0xFFFFu;

  NimblePoolWatermark nimble;
  captureNimblePoolWatermark(&nimble);
  uint32_t nimbleBlocks = nimble.minFreeBlocks;
  uint32_t nimbleBlockSizeDiv8 = (nimble.blockSize + 7u) / 8u;
  if (nimbleBlocks > 0xFFu) nimbleBlocks = 0xFFu;
  if (nimbleBlockSizeDiv8 > 0xFFu) nimbleBlockSizeDiv8 = 0xFFu;

  uint32_t txQueued = status.msgs_to_tx;
  uint32_t rxQueued = status.msgs_to_rx;
  uint8_t txPacked = static_cast<uint8_t>((txQueued > 0x0Fu) ? 0x0Fu : txQueued);
  uint8_t rxPacked = static_cast<uint8_t>((rxQueued > 0xFFu) ? 0xFFu : rxQueued);

  uint8_t payload[8];
  // payload v2 layout:
  //   byte0: [7:4]=version, [3:0]=CAN TX queue depth (clamped to 15)
  //   byte1: CAN RX queue depth (clamped to 255)
  //   byte2: NimBLE min-free block count (clamped to 255)
  //   byte3: NimBLE block size in units of 8 bytes (ceil, clamped to 255)
  //   byte4-5: minimum heap free in units of 32 bytes (little-endian)
  //   byte6-7: current heap free in units of 32 bytes (little-endian)
  payload[0] = static_cast<uint8_t>((0x02u << 4) | txPacked);
  payload[1] = rxPacked;
  payload[2] = static_cast<uint8_t>(nimbleBlocks & 0xFFu);
  payload[3] = static_cast<uint8_t>(nimbleBlockSizeDiv8 & 0xFFu);
  payload[4] = static_cast<uint8_t>(heapMinUnits & 0xFFu);
  payload[5] = static_cast<uint8_t>((heapMinUnits >> 8) & 0xFFu);
  payload[6] = static_cast<uint8_t>(heapFreeUnits & 0xFFu);
  payload[7] = static_cast<uint8_t>((heapFreeUnits >> 8) & 0xFFu);

  bleSendCanData(0x777, payload, sizeof(payload));
}

static void resetSkippedUpdatesCounters() {
  struct { void operator()(void *entry) {
    PidExtra &extra = ((SimplePidMap<PidExtra>::Entry*)entry)->extra;
    extra.skippedUpdates = 0;
    extra.hasLastPayload = false;
    extra.lastLength = 0;
  }} fun;
  pidMap.forEach(fun);
}

// ===== Profile application =====
static void apply_allow_list_profile() {
  GovernorSnapshot snapshots[BLE_GOVERNOR_SNAPSHOT_MAX];
  size_t snapshotCount = capture_governor_snapshot(snapshots);

  pidMap.reset();
  clearDeny(); // optional fresh start
  bleTxOverLimitSinceMs = 0;
  bleTxBelowLimitSinceMs = 0;
  const auto *map = active_pid_map();
  if (map) {
    for (size_t i = 0; i < map->ruleCount; ++i) {
      const PidRule &r = map->rules[i];
      pidMap.allowOnePid(r.pid, /*ms*/40);
      if (PidExtra *extra = pidMap.getOrCreateExtra(r.pid)) {
        uint8_t base = (r.divider == 0 ? 1 : r.divider);
        set_extra_base_divider(extra, base, /*resetGovernor=*/false);
      }
    }
  }
  bool restored = restore_governor_snapshot(snapshots, snapshotCount);
  bleGovernorActive = restored;
}

static void apply_allow_all() {
  GovernorSnapshot snapshots[BLE_GOVERNOR_SNAPSHOT_MAX];
  size_t snapshotCount = capture_governor_snapshot(snapshots);

  pidMap.reset();
  clearDeny();
  bleTxOverLimitSinceMs = 0;
  bleTxBelowLimitSinceMs = 0;
  // Entries will be created lazily when packets arrive or dividers are customized.
  bool restored = restore_governor_snapshot(snapshots, snapshotCount);
  bleGovernorActive = restored;
}

static void apply_profile_and_dividers() {
  if (USE_PROFILE_ALLOWLIST) {
    apply_allow_list_profile();
  } else {
    apply_allow_all();
  }
  piddiv_apply_all();
}

// ===== Oil publish =====
static void oil_update_and_publish_if_due() {
  const uint32_t now = millis();
  float v = filtered_adc_volts();
  oil_flags = oil_health_flags_from_volts(v);
  oil_psi_f = volts_to_psi_exact(v);

  if (bleIsConnected() && (now - lastOilTxMs) >= OIL_TX_RATE_MS) {
    lastOilTxMs = now;
    uint16_t psi01 = (uint16_t)(oil_psi_f * OIL_SCALE_01PSI + 0.5f);
    uint8_t d[8] = {
      (uint8_t)(psi01 >> 8), (uint8_t)(psi01 & 0xFF),
      oil_flags, 0, 0, 0, 0, 0
    };
    bleSendCanData(OIL_CAN_ID, d, 8);
  }
}

// ===== Concise config print (SHOW) =====
static void show_config() {
  Serial.println("=== CCA Config ===");
  Serial.printf("Profile:        %s\n", USE_PROFILE_ALLOWLIST ? "ALLOW-LIST" : "SNIFF-ALL");
  Serial.printf("V0_ADC:         %.4f V\n", V0_ADC);
  Serial.printf("V1_ADC:         %.4f V\n", V1_ADC);
  Serial.printf("Custom divs:    %u\n", (unsigned)customDividerCount);
  Serial.printf("FIL token:      %08lX\n", (unsigned long)CFG_TOKEN);
  Serial.println("==================");
}

// ===== Verbose dumps (on demand only) =====
static void show_stats() {
  Serial.println("=== CCA Stats ===");
  Serial.printf("RX count:        %lu\n", (unsigned long)rxCount);
  Serial.printf("CAN timeouts:    %u\n", (unsigned)num_can_bus_timeouts);
  Serial.printf("CAN restarts:    %lu\n", (unsigned long)canRestartCount);
  Serial.printf("CAN bus-off:     %lu\n", (unsigned long)canBusOffCount);
  Serial.printf("CAN notifies suppressed: %lu\n",
                (unsigned long)notifies_suppressed_total);
  uint32_t now = millis();
  uint32_t sinceRestartMs = lastCanRestartMs ? (now - lastCanRestartMs) : 0;
  Serial.printf("Last CAN restart:%lu s ago\n", (unsigned long)(sinceRestartMs / 1000UL));
  Serial.printf("BLE tx avg:      %.1f fps\n", bleTxMovingAverageFps);
  Serial.printf("BLE governor:    %s\n", bleGovernorActive ? "ACTIVE" : "idle");
  Serial.printf("BLE MTU/value:   %u/%u (loop cap=%u)\n",
                static_cast<unsigned>(g_bleNegotiatedMtu),
                static_cast<unsigned>(g_bleNotifyMaxValueLength),
                static_cast<unsigned>(g_bleNotifyBurstBudgetPerLoop));
  Serial.printf("BLE notify errs: failures=%lu status=%lu congestion=%lu clamps=%lu\n",
                static_cast<unsigned long>(bleNotifyFailuresTotal),
                static_cast<unsigned long>(bleNotifyStatusErrors),
                static_cast<unsigned long>(bleNotifyCongestionEvents),
                static_cast<unsigned long>(bleNotifyClampEvents));
  Serial.printf("BLE backoff:     events=%lu active=%s last=%s\n",
                static_cast<unsigned long>(bleNotifyBackoffEvents),
                bleNotifyBackoffActive ? "yes" : "no",
                bleNotifyBackoffLastReason);
  const auto &supCan = g_supervisor.stats(Supervisor::Subsystem::CanPoll);
  const auto &supGps = g_supervisor.stats(Supervisor::Subsystem::GpsService);
  const auto &supBle = g_supervisor.stats(Supervisor::Subsystem::BleBurst);
  Serial.printf("Supervisor faults: CAN=%lu GPS=%lu BLE=%lu\n",
                (unsigned long)supCan.faults,
                (unsigned long)supGps.faults,
                (unsigned long)supBle.faults);
  Serial.printf("Supervisor max us: CAN=%lu GPS=%lu BLE=%lu\n",
                (unsigned long)supCan.maxUs,
                (unsigned long)supGps.maxUs,
                (unsigned long)supBle.maxUs);
  Serial.printf("Last reconnect:  %s\n", lastReconnectCause);
  Serial.printf("FW: %s\n", FW_VERSION_STRING);
  Serial.println("=================");
}

static void dumpMapToSerial() {
  Serial.println("PID map:");
  if (pidMap.isEmpty()) { Serial.println("  <empty>\n"); return; }
  size_t total = 0;
  size_t printed = 0;
  pidMap.forEach([&](void *entry) {
    total++;
    if (printed >= 128) return;
    uint32_t pid = ((SimplePidMap<PidExtra>::Entry*)entry)->pid;
    const PidExtra *e = &((SimplePidMap<PidExtra>::Entry*)entry)->extra;
    Serial.printf("  %03lX: base=%u eff=%u\n",
                  (unsigned long)pid,
                  (unsigned)e->baseDivider,
                  (unsigned)effective_divider(e));
    printed++;
  });
  if (total > 128) {
    Serial.printf("  ... +%u more\n", (unsigned)(total - 128));
  }
  Serial.println();
}
static void dumpDenyToSerial() {
  Serial.println("Deny list:");
  if (denyCount == 0) { Serial.println("  <empty>\n"); return; }
  for (size_t i = 0; i < denyCount; ++i) {
    Serial.printf("  0x%03lX (%lu)\n", (unsigned long)denyList[i], (unsigned long)denyList[i]);
  }
  Serial.println();
}

// ===== Serial CLI =====
static constexpr size_t CLI_BUF_SIZE = 192;
static void process_cli_line(char *line) {
  while (*line == ' ' || *line == '\t') ++line;
  size_t L = strlen(line);
  while (L && (line[L-1] == ' ' || line[L-1] == '\t')) line[--L] = 0;
  if (!L) return;

  String s(line);
  String up = s; up.toUpperCase();

  if (up == "SHOW") {
    Serial.println("SHOW subcommands:");
    Serial.println("  CFG   -> config summary");
    Serial.println("  STATS -> runtime counters");
    Serial.println("  MAP   -> enabled PID allow-list");
    return;
  }
  if (up == "SHOW CFG")   { show_config(); return; }
  if (up == "SHOW STATS") { show_stats(); return; }
  if (up == "SHOW MAP")        { dumpMapToSerial(); return; }
  if (up == "SHOW DENY")       { dumpDenyToSerial(); return; }

  if (up == "CAL 0") {
    float sample = filtered_adc_volts();
    if (!isnan(sample)) {
      if (sample >= V1_ADC) {
        Serial.printf("CAL 0: %.4f V >= V1 (%.4f V); aborting.\n", sample, V1_ADC);
      } else {
        V0_ADC = sample;
        bool saved = oil_calibration_save(V0_ADC, V1_ADC);
        Serial.printf("V0_ADC=%.4f (%s)\n", V0_ADC, saved ? "saved" : "save FAILED");
      }
    } else {
      Serial.println("CAL 0: invalid sample; keeping previous value.");
    }
    return;
  }
  if (up == "CAL 1") {
    float sample = filtered_adc_volts();
    if (!isnan(sample)) {
      if (sample <= V0_ADC) {
        Serial.printf("CAL 1: %.4f V <= V0 (%.4f V); aborting.\n", sample, V0_ADC);
      } else {
        V1_ADC = sample;
        bool saved = oil_calibration_save(V0_ADC, V1_ADC);
        Serial.printf("V1_ADC=%.4f (%s)\n", V1_ADC, saved ? "saved" : "save FAILED");
      }
    } else {
      Serial.println("CAL 1: invalid sample; keeping previous value.");
    }
    return;
  }
  if (up == "CAL SHOW") {
    OilCalibrationRaw raw;
    if (!oil_calibration_read_raw(&raw) || !raw.present) {
      Serial.println("No oil calibration stored.");
    } else {
      Serial.println("=== Oil Calibration (raw) ===");
      Serial.printf("Version:      %u%s\n", (unsigned)raw.version, raw.valid ? "" : " (invalid)");
      Serial.printf("V0_ADC:       %.4f V\n", raw.v0_adc);
      Serial.printf("V1_ADC:       %.4f V\n", raw.v1_adc);
      Serial.printf("Stored CRC32: 0x%08lX\n", (unsigned long)raw.stored_crc32);
      Serial.printf("CRC32 calc:   0x%08lX\n", (unsigned long)raw.computed_crc32);
      Serial.println("=============================");
    }
    return;
  }

  if (up == "PROFILE ON") {
    USE_PROFILE_ALLOWLIST = true;
    apply_profile_and_dividers();
    Serial.println("Profile=ALLOW-LIST (not saved)");
    return;
  }
  if (up == "PROFILE OFF") {
    USE_PROFILE_ALLOWLIST = false;
    apply_profile_and_dividers();
    Serial.println("Profile=SNIFF-ALL (not saved)");
    return;
  }

  if (up.startsWith("RATE ")) {
    char buf[CLI_BUF_SIZE]; strncpy(buf, line, sizeof(buf)); buf[sizeof(buf)-1]=0;
    char *tok = strtok(buf + 5, " \t");
    if (tok) {
      unsigned ms = strtoul(tok, nullptr, 0);
      if (ms < 10 || ms > 2000) { Serial.println("RATE out of range (10..2000 ms)"); }
      else { OIL_TX_RATE_MS = (uint16_t)ms; Serial.printf("RATE=%u ms (not saved)\n", ms); }
    } else Serial.println("Usage: RATE <ms>");
    return;
  }

  if (up.startsWith("ALLOW ")) {
    char buf[CLI_BUF_SIZE]; strncpy(buf, line, sizeof(buf)); buf[sizeof(buf)-1]=0;
    char *tok = strtok(buf + 6, " \t");
    char *tok2 = tok ? strtok(nullptr, " \t") : nullptr;
    if (tok && tok2) {
      uint32_t pid = strtoul(tok, nullptr, 0);
      unsigned n   = strtoul(tok2, nullptr, 0);
      if (n == 0) n = 1; if (n > 255) n = 255;
      removeDeny(pid);
      if (!pidMap.allowOnePid(pid, 40)) {
        Serial.println("ALLOW failed (map full?)");
      } else {
        if (!piddiv_set(pid, (uint8_t)n)) {
          Serial.println("WARNING: Custom divider table full; divider not persisted.");
        }
        Serial.printf("ALLOW 0x%03lX div=%u\n", (unsigned long)pid, (unsigned)n);
      }
    } else {
      Serial.println("Usage: ALLOW <pid> <div>");
    }
    return;
  }

  if (up.startsWith("DENY ")) {
    char buf[CLI_BUF_SIZE]; strncpy(buf, line, sizeof(buf)); buf[sizeof(buf)-1]=0;
    char *tok = strtok(buf + 5, " \t");
    if (tok) {
      uint32_t pid = strtoul(tok, nullptr, 0);
      addDeny(pid);
      Serial.printf("DENY  0x%03lX\n", (unsigned long)pid);
    } else {
      Serial.println("Usage: DENY <pid>");
    }
    return;
  }

  if (up.startsWith("TOKEN")) {
    char buf[CLI_BUF_SIZE]; strncpy(buf, line, sizeof(buf)); buf[sizeof(buf)-1]=0;
    char *tok = strtok(buf + 5, " \t");
    if (!tok || tok[0] == '\0') {
      Serial.printf("Current FIL token: %08lX\n", (unsigned long)CFG_TOKEN);
      Serial.println("Usage: TOKEN <hex8>");
      return;
    }
    char *endptr = nullptr;
    unsigned long parsed = strtoul(tok, &endptr, 16);
    if ((endptr && *endptr) || parsed == 0) {
      Serial.println("TOKEN expects 8 hex digits (non-zero).");
      return;
    }
    CFG_TOKEN = static_cast<uint32_t>(parsed);
    bool saved = save_cfg_token_value(CFG_TOKEN);
    Serial.printf("FIL token set to %08lX (%s)\n",
                  (unsigned long)CFG_TOKEN,
                  saved ? "saved" : "save FAILED");
    return;
  }

  if (up == "SAVE") {
    if (cfg_save_to_nvs()) Serial.println("Saved.");
    else Serial.println("SAVE failed.");
    show_config();
    return;
  }

  if (up == "LOAD") {
    bool ok = cfg_load_from_nvs();
    if (!ok) {
      Serial.println("No saved config; using defaults.");
      cfg_apply_runtime_defaults();
    }
    apply_profile_and_dividers();
    show_config();
    return;
  }

  if (up == "RESETCFG") {
    if (cfg_reset_to_defaults()) Serial.println("Config reset to defaults.");
    else                         Serial.println("Failed to reset config.");
    apply_profile_and_dividers();
    show_config();
    return;
  }

  Serial.println("Unknown cmd. Try: SHOW | SHOW CFG | SHOW STATS | SHOW MAP | SHOW DENY | CAL 0 | CAL 1 | CAL SHOW | RATE <ms> | PROFILE ON|OFF | ALLOW <pid> <div> | DENY <pid> | TOKEN <hex8> | SAVE | LOAD | RESETCFG");
}

// ===== Main loop =====
void loop() {
  loop_iteration++;
  esp_task_wdt_reset();

  g_supervisor.beginLoop();

  canNotifiesThisLoop = 0;
  notifyCapHitCurrentLoop = false;

  servicePendingBleRestart();
  bleLinkPri_attachIfReady();

  // Handle disconnect / reconnect
  if ((loop_iteration % 100) == 0 && !bleIsConnected()) {
    if (nvsWriteInProgress && !pendingBleRestart) {
      Serial.println("RC disconnected during SAVE; deferring until NVS completes.");
    }
    queueBleRestart("RC disconnect");
    servicePendingBleRestart();
  }

  // Ensure CAN is up
  while (!isCanBusReaderActive) {
    esp_task_wdt_reset();
    if (startCanBusReader()) {
      flushBufferedPackets();
      resetSkippedUpdatesCounters();
      lastCanMessageReceivedMs = millis();
      break;
    }
    for (int i = 0; i < 25; ++i) {
      led_service(millis());
      delay(20);
    }
  }

  const uint32_t now = millis();

  bleLinkPri_service(now);
  refreshBleLed();

  bool canFaulted = checkCanBusHealth(now);
  bool twaiRunning = (lastTwaiStatus.state == TWAI_STATE_RUNNING);
  bool recentCan = have_seen_any_can && (now - lastCanMessageReceivedMs <= 1000);

  LedPattern canPattern = LedPattern::BlinkSlow;  // ready but waiting for bus activity
  if (twaiRunning && have_seen_any_can) {
    canPattern = recentCan ? LedPattern::Pulse2Every2s : LedPattern::Solid;
  }
  led_set_can(canPattern);
  if (canFaulted) {
    led_service(now);
    return;
  }

  // Watchdog after first frame
  if (have_seen_any_can && (now - lastCanMessageReceivedMs > 2000)) {
    handleCanFault("CAN RX timeout");
    led_service(millis());
    return;
  }

  // BLE heartbeat (2 Hz)
  if (bleIsConnected() && every(now, &lastHbMs, 500)) {
    uint8_t hb[2] = { (uint8_t)(hbCounter & 0xFF), (uint8_t)(hbCounter >> 8) };
    bleSendCanData(HB_PID, hb, 2);
    hbCounter++;
  }

  // TWAI RX -> buffer (within a short budget so GPS isn't starved)
  CanFrame rx;
  uint32_t canPollStartUs = micros();
  uint32_t framesPolled = 0;
  while (true) {
    bool bufferFull = (bufferedPacketCount() == static_cast<uint32_t>(NUM_BUFFERS));
    BufferedMessage *fastSlot = bufferFull ? nullptr : &buffers[bufferToWriteTo % NUM_BUFFERS];
    bool fastSlotAligned = fastSlot &&
                           ((reinterpret_cast<uintptr_t>(fastSlot->frame.data) & (alignof(uint32_t) - 1)) == 0);

    CanFrame *target = fastSlotAligned ? &fastSlot->frame : &rx;

    if (!ESP32Can.readFrame(*target, 0)) {
      break;
    }

    uint32_t t_us_rx = micros();

    framesPolled++;
    if (target->rtr) {
      if ((framesPolled % CAN_RX_BUDGET_CHECK_INTERVAL) == 0) {
        uint32_t elapsedUs = micros() - canPollStartUs;
        if (elapsedUs >= CAN_RX_READ_BUDGET_US) {
          break;
        }
      }
      continue;
    }

    uint32_t frameNow = millis();
    have_seen_any_can = true;
    lastCanMessageReceivedMs = frameNow;

    uint8_t dlc = target->data_length_code;
    if (dlc > 8) {
      Serial.printf("WARN: dropping CAN frame id=%03X with invalid DLC=%u\n",
                    target->identifier, dlc);
      continue;
    }

    rxCount++;
    if (frameNow - lastRxPrintMs >= CAN_RX_PRINT_INTERVAL_MS) {
      lastRxPrintMs = frameNow;
      Serial.printf("RX #%lu id=%03X dlc=%u\n", (unsigned long)rxCount,
                    target->identifier, dlc);
    }

    if (dlc) {
      if (fastSlotAligned && dlc <= CAN_RX_FASTPATH_MAX_DLC) {
        fastSlot->frame.data_length_code = dlc;
        fastSlot->t_us_rx = t_us_rx;
        bufferToWriteTo++;
      } else {
        bufferNewPacket(*target, t_us_rx);
      }
    } else {
      diagRecordFrame(target->identifier, 0, t_us_rx);
    }

    if ((framesPolled % CAN_RX_BUDGET_CHECK_INTERVAL) == 0) {
      uint32_t elapsedUs = micros() - canPollStartUs;
      if (elapsedUs >= CAN_RX_READ_BUDGET_US) {
        break;
      }
    }
  }

  uint32_t canPollElapsedUs = micros() - canPollStartUs;
  g_supervisor.noteElapsed(Supervisor::Subsystem::CanPoll, canPollElapsedUs);

  // Forward bursts within a small time budget
  uint32_t bleBurstStartUs = micros();
  handleBufferedPacketsBurst(2000);
  uint32_t bleBurstElapsedUs = micros() - bleBurstStartUs;
  g_supervisor.noteElapsed(Supervisor::Subsystem::BleBurst, bleBurstElapsedUs);

  // Oil channel
  oil_update_and_publish_if_due();
  LedPattern oilPattern = LedPattern::Off;
  if (oil_flags == 0) {
    oilPattern = LedPattern::Solid;
  } else if (oil_flags & (1 << 1)) {
    oilPattern = LedPattern::BlinkFast;  // sensor short to ground
  } else if (oil_flags & (1 << 0)) {
    oilPattern = LedPattern::Pulse2Every2s;  // harness open
  } else {
    oilPattern = LedPattern::BlinkSlow;  // out-of-range but not hard fault
  }
  led_set_oil(oilPattern);

  uint32_t postCanNow = millis();

  logNotifyCapIfNeeded(postCanNow);

  // Periodic CAN diagnostic frame
  sendCanDiagnostics(postCanNow);
  serviceDiagStream();
  bleNotifyBackoffService(postCanNow);

  // GPS service (read UART + notify BLE)
  uint32_t gpsStartUs = micros();
  gpsService(postCanNow);
  uint32_t gpsElapsedUs = micros() - gpsStartUs;
  g_supervisor.noteElapsed(Supervisor::Subsystem::GpsService, gpsElapsedUs);

  uint32_t gpsNow = millis();
  bool gpsRecent = (gpsLastSentenceMs != 0) && (gpsNow - gpsLastSentenceMs <= 1200);
  LedPattern gpsPattern = LedPattern::BlinkSlow;  // ready, waiting on fix/data
  if (gpsRecent && rmc_valid) {
    gpsPattern = LedPattern::Pulse3Every2s;
  } else if (gpsRecent) {
    gpsPattern = LedPattern::Solid;
  }
  led_set_gps(gpsPattern);

  updateBleGovernor(postCanNow);

  bool sysBlink = bleGovernorActive || notifyCapHitCurrentLoop;
  led_set_sys(sysBlink ? LedPattern::BlinkSlow : LedPattern::Off);

  led_service(gpsNow);

  // ---- Robust Serial CLI: accept CR, LF, CRLF, or no line ending ----
  static char cliBuf[CLI_BUF_SIZE];
  static size_t cliLen = 0;
  static bool cliOverflow = false;
  while (Serial.available()) {
    int c = Serial.read();
    if (c < 0) break;
    if (c == '\r' || c == '\n') {
      cliBuf[cliLen] = 0;
      if (cliOverflow) {
        Serial.println("CLI line too long; ignored.");
      } else if (cliLen) {
        process_cli_line(cliBuf);
      }
      cliLen = 0;
      cliOverflow = false;
      if (Serial.peek() == '\n' || Serial.peek() == '\r') Serial.read();
    } else if (cliLen < (CLI_BUF_SIZE - 1)) {
      cliBuf[cliLen++] = (char)c;
    } else {
      cliOverflow = true;
    }
  }
}
